# é«˜çº§ä¸»é¢˜ä¸æœ€ä½³å®è·µ

## ç›®å½•
- [å¤šç§Ÿæˆ·è®¤è¯](#å¤šç§Ÿæˆ·è®¤è¯)
- [åˆ†å¸ƒå¼ä¼šè¯ç®¡ç†](#åˆ†å¸ƒå¼ä¼šè¯ç®¡ç†)
- [å¾®æœåŠ¡å®‰å…¨æ¶æ„](#å¾®æœåŠ¡å®‰å…¨æ¶æ„)
- [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
- [å®¡è®¡æ—¥å¿—ä¸ç›‘æ§](#å®¡è®¡æ—¥å¿—ä¸ç›‘æ§)
- [å®‰å…¨æœ€ä½³å®è·µæ±‡æ€»](#å®‰å…¨æœ€ä½³å®è·µæ±‡æ€»)

---

## å¤šç§Ÿæˆ·è®¤è¯

### ä»€ä¹ˆæ˜¯å¤šç§Ÿæˆ·ï¼Ÿ

**å¤šç§Ÿæˆ·ï¼ˆMulti-Tenancyï¼‰** æ˜¯ä¸€ç§è½¯ä»¶æ¶æ„ï¼Œå•ä¸ªåº”ç”¨å®ä¾‹å¯ä»¥æœåŠ¡å¤šä¸ªç§Ÿæˆ·ï¼ˆå®¢æˆ·ï¼‰ï¼Œæ¯ä¸ªç§Ÿæˆ·çš„æ•°æ®ç›¸äº’éš”ç¦»ã€‚

### å¤šç§Ÿæˆ·éš”ç¦»ç­–ç•¥

1. **æ•°æ®åº“çº§éš”ç¦»**ï¼šæ¯ä¸ªç§Ÿæˆ·ç‹¬ç«‹æ•°æ®åº“
2. **Schemaçº§éš”ç¦»**ï¼šå…±äº«æ•°æ®åº“ï¼Œç‹¬ç«‹Schema
3. **è¡¨çº§éš”ç¦»**ï¼šå…±äº«è¡¨ï¼Œé€šè¿‡tenant_idå­—æ®µåŒºåˆ†

### å®ç°å¤šç§Ÿæˆ·è®¤è¯

#### æ–¹å¼1ï¼šåŸºäºå­åŸŸå

```
tenant1.example.com â†’ ç§Ÿæˆ·1
tenant2.example.com â†’ ç§Ÿæˆ·2
```

```java
/**
 * ç§Ÿæˆ·è¯†åˆ«å™¨
 */
@Component
public class TenantIdentifierResolver {
    
    /**
     * ä»è¯·æ±‚ä¸­æå–ç§Ÿæˆ·æ ‡è¯†
     */
    public String resolveTenantIdentifier(HttpServletRequest request) {
        // æ–¹å¼1: ä»å­åŸŸåæå–
        String host = request.getServerName();
        if (host.contains(".")) {
            String subdomain = host.substring(0, host.indexOf("."));
            if (!subdomain.equals("www")) {
                return subdomain;
            }
        }
        
        // æ–¹å¼2: ä»è¯·æ±‚å¤´æå–
        String tenantHeader = request.getHeader("X-Tenant-ID");
        if (tenantHeader != null) {
            return tenantHeader;
        }
        
        // æ–¹å¼3: ä»JWT Tokenæå–
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.getCredentials() instanceof Jwt) {
            Jwt jwt = (Jwt) auth.getCredentials();
            return jwt.getClaimAsString("tenant_id");
        }
        
        return "default";
    }
}
```

#### æ–¹å¼2ï¼šåŸºäºJWT Token

```java
/**
 * å¤šç§Ÿæˆ·JWT Token Provider
 */
@Component
public class MultiTenantJwtTokenProvider {
    
    @Autowired
    private TenantService tenantService;
    
    /**
     * ç”ŸæˆåŒ…å«ç§Ÿæˆ·ä¿¡æ¯çš„Token
     */
    public String generateToken(Authentication authentication, String tenantId) {
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        
        // éªŒè¯ç”¨æˆ·æ˜¯å¦å±äºè¯¥ç§Ÿæˆ·
        if (!tenantService.userBelongsToTenant(userDetails.getUsername(), tenantId)) {
            throw new IllegalArgumentException("User does not belong to tenant");
        }
        
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + 3600000);
        
        return Jwts.builder()
            .setSubject(userDetails.getUsername())
            .claim("tenant_id", tenantId)
            .claim("tenant_name", tenantService.getTenantName(tenantId))
            .claim("authorities", userDetails.getAuthorities())
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(key, SignatureAlgorithm.HS512)
            .compact();
    }
}
```

#### æ•°æ®éš”ç¦»

```java
/**
 * ç§Ÿæˆ·ä¸Šä¸‹æ–‡
 */
public class TenantContext {
    
    private static final ThreadLocal<String> CURRENT_TENANT = new ThreadLocal<>();
    
    public static void setTenantId(String tenantId) {
        CURRENT_TENANT.set(tenantId);
    }
    
    public static String getTenantId() {
        return CURRENT_TENANT.get();
    }
    
    public static void clear() {
        CURRENT_TENANT.remove();
    }
}

/**
 * ç§Ÿæˆ·è¯†åˆ«è¿‡æ»¤å™¨
 */
@Component
public class TenantIdentifierFilter extends OncePerRequestFilter {
    
    @Autowired
    private TenantIdentifierResolver tenantIdentifierResolver;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) 
            throws ServletException, IOException {
        
        try {
            String tenantId = tenantIdentifierResolver.resolveTenantIdentifier(request);
            TenantContext.setTenantId(tenantId);
            filterChain.doFilter(request, response);
        } finally {
            TenantContext.clear();
        }
    }
}

/**
 * JPAæ•°æ®è¿‡æ»¤
 */
@Entity
@Table(name = "orders")
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = "string"))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "tenant_id", nullable = false)
    private String tenantId;
    
    // å…¶ä»–å­—æ®µ...
}

/**
 * è‡ªåŠ¨è®¾ç½®ç§Ÿæˆ·ID
 */
@Component
public class TenantEntityListener {
    
    @PrePersist
    public void setTenantId(Object entity) {
        if (entity instanceof TenantAware) {
            TenantAware tenantAware = (TenantAware) entity;
            if (tenantAware.getTenantId() == null) {
                tenantAware.setTenantId(TenantContext.getTenantId());
            }
        }
    }
}
```

---

## åˆ†å¸ƒå¼ä¼šè¯ç®¡ç†

### ä¸ºä»€ä¹ˆéœ€è¦åˆ†å¸ƒå¼ä¼šè¯ï¼Ÿ

åœ¨å¾®æœåŠ¡æˆ–é›†ç¾¤ç¯å¢ƒä¸­ï¼Œç”¨æˆ·è¯·æ±‚å¯èƒ½è¢«è·¯ç”±åˆ°ä¸åŒæœåŠ¡å™¨ï¼Œéœ€è¦å…±äº«ä¼šè¯æ•°æ®ã€‚

### è§£å†³æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **Sticky Session** | ç®€å•ï¼Œæ— éœ€é¢å¤–å­˜å‚¨ | å•ç‚¹æ•…éšœï¼Œè´Ÿè½½ä¸å‡ | å°è§„æ¨¡åº”ç”¨ |
| **Sessionå¤åˆ¶** | é«˜å¯ç”¨ | ç½‘ç»œå¼€é”€å¤§ï¼Œä¸é€‚åˆå¤§é›†ç¾¤ | ä¸­å°è§„æ¨¡ |
| **é›†ä¸­å¼å­˜å‚¨** | æ‰©å±•æ€§å¥½ï¼Œé«˜å¯ç”¨ | éœ€è¦é¢å¤–ç»„ä»¶ | å¤§è§„æ¨¡ç”Ÿäº§ç¯å¢ƒ |
| **JWT Token** | æ— çŠ¶æ€ï¼Œæ˜“æ‰©å±• | æ— æ³•ä¸»åŠ¨åŠé”€ | å¾®æœåŠ¡ã€API |

### ä½¿ç”¨Rediså®ç°åˆ†å¸ƒå¼ä¼šè¯

#### Spring Session + Redis

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.session</groupId>
        <artifactId>spring-session-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
</dependencies>
```

```java
/**
 * Spring Sessioné…ç½®
 */
@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800)  // 30åˆ†é’Ÿ
public class RedisSessionConfig {
    
    @Bean
    public LettuceConnectionFactory connectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("localhost");
        config.setPort(6379);
        config.setPassword("password");
        
        return new LettuceConnectionFactory(config);
    }
    
    /**
     * Sessionåºåˆ—åŒ–å™¨
     */
    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        return new GenericJackson2JsonRedisSerializer();
    }
    
    /**
     * Cookieåºåˆ—åŒ–ç­–ç•¥
     */
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();
        serializer.setCookieName("SESSIONID");
        serializer.setCookiePath("/");
        serializer.setDomainNamePattern("^.+?\\.(\\w+\\.[a-z]+)$");  // è·¨å­åŸŸ
        serializer.setUseHttpOnlyCookie(true);
        serializer.setUseSecureCookie(true);
        serializer.setSameSite("Lax");
        return serializer;
    }
}
```

```properties
# application.properties
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
spring.session.store-type=redis
spring.session.redis.namespace=spring:session
```

### è‡ªå®šä¹‰Sessionå­˜å‚¨

```java
/**
 * è‡ªå®šä¹‰Session Repository
 */
@Component
public class CustomSessionRepository implements SessionRepository<CustomSession> {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String SESSION_PREFIX = "session:";
    private static final int DEFAULT_MAX_INACTIVE_INTERVAL = 1800;
    
    @Override
    public CustomSession createSession() {
        CustomSession session = new CustomSession();
        session.setId(UUID.randomUUID().toString());
        session.setMaxInactiveInterval(Duration.ofSeconds(DEFAULT_MAX_INACTIVE_INTERVAL));
        session.setCreationTime(Instant.now());
        session.setLastAccessedTime(Instant.now());
        return session;
    }
    
    @Override
    public void save(CustomSession session) {
        String key = SESSION_PREFIX + session.getId();
        session.setLastAccessedTime(Instant.now());
        
        redisTemplate.opsForHash().putAll(key, session.toMap());
        redisTemplate.expire(key, session.getMaxInactiveInterval());
    }
    
    @Override
    public CustomSession findById(String id) {
        String key = SESSION_PREFIX + id;
        Map<Object, Object> entries = redisTemplate.opsForHash().entries(key);
        
        if (entries.isEmpty()) {
            return null;
        }
        
        CustomSession session = CustomSession.fromMap(entries);
        
        // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
        if (session.isExpired()) {
            deleteById(id);
            return null;
        }
        
        return session;
    }
    
    @Override
    public void deleteById(String id) {
        String key = SESSION_PREFIX + id;
        redisTemplate.delete(key);
    }
}
```

### Sessionæ´»åŠ¨ç›‘æ§

```java
/**
 * Sessionæ´»åŠ¨ç›‘æ§
 */
@Component
public class SessionActivityMonitor {
    
    @Autowired
    private SessionRegistry sessionRegistry;
    
    /**
     * è·å–æ´»è·ƒä¼šè¯æ•°
     */
    public int getActiveSessionCount() {
        return sessionRegistry.getAllPrincipals().stream()
            .mapToInt(principal -> sessionRegistry.getAllSessions(principal, false).size())
            .sum();
    }
    
    /**
     * è·å–ç”¨æˆ·ä¼šè¯
     */
    public List<SessionInfo> getUserSessions(String username) {
        List<SessionInfo> sessions = new ArrayList<>();
        
        for (Object principal : sessionRegistry.getAllPrincipals()) {
            if (principal.toString().equals(username)) {
                List<SessionInformation> userSessions = 
                    sessionRegistry.getAllSessions(principal, false);
                
                for (SessionInformation si : userSessions) {
                    SessionInfo info = new SessionInfo();
                    info.setSessionId(si.getSessionId());
                    info.setLastRequest(si.getLastRequest());
                    info.setExpired(si.isExpired());
                    sessions.add(info);
                }
            }
        }
        
        return sessions;
    }
    
    /**
     * å®šæœŸæ¸…ç†è¿‡æœŸä¼šè¯
     */
    @Scheduled(fixedRate = 60000)  // æ¯åˆ†é’Ÿ
    public void cleanupExpiredSessions() {
        for (Object principal : sessionRegistry.getAllPrincipals()) {
            List<SessionInformation> sessions = 
                sessionRegistry.getAllSessions(principal, true);  // åŒ…å«è¿‡æœŸ
            
            for (SessionInformation si : sessions) {
                if (si.isExpired()) {
                    sessionRegistry.removeSessionInformation(si.getSessionId());
                }
            }
        }
    }
}
```

---

## å¾®æœåŠ¡å®‰å…¨æ¶æ„

### æ¶æ„æ¨¡å¼

#### 1. è¾¹ç¼˜è®¤è¯æ¨¡å¼ï¼ˆGateway Authenticationï¼‰

```
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
User â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚  API Gateway â”‚  â† JWTéªŒè¯
                          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚            â”‚            â”‚
                â”Œâ”€â”€â”€â–¼â”€â”€â”€â”    â”Œâ”€â”€â”€â–¼â”€â”€â”€â”   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
                â”‚Serviceâ”‚    â”‚Serviceâ”‚   â”‚Serviceâ”‚
                â”‚   A   â”‚    â”‚   B   â”‚   â”‚   C   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç‰¹ç‚¹ï¼š**
- è®¤è¯åœ¨ç½‘å…³ç»Ÿä¸€å¤„ç†
- å†…éƒ¨æœåŠ¡ä¿¡ä»»ç½‘å…³
- ç®€åŒ–æœåŠ¡å¼€å‘

**å®ç°ï¼š**

```java
/**
 * Gateway JWTè¿‡æ»¤å™¨
 */
@Component
public class GatewayJwtFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // å…¬å¼€è·¯å¾„è·³è¿‡è®¤è¯
        if (isPublicPath(request.getPath().value())) {
            return chain.filter(exchange);
        }
        
        // æå–å¹¶éªŒè¯JWT
        String token = extractToken(request);
        if (token == null || !tokenProvider.validateToken(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        
        // ä»Tokenæå–ç”¨æˆ·ä¿¡æ¯ï¼Œæ·»åŠ åˆ°è¯·æ±‚å¤´ä¼ é€’ç»™åç«¯æœåŠ¡
        String username = tokenProvider.getUsernameFromToken(token);
        String userId = tokenProvider.getClaimFromToken(token, "user_id");
        
        ServerHttpRequest modifiedRequest = request.mutate()
            .header("X-User-Id", userId)
            .header("X-Username", username)
            .build();
        
        return chain.filter(exchange.mutate().request(modifiedRequest).build());
    }
    
    @Override
    public int getOrder() {
        return -100;  // é«˜ä¼˜å…ˆçº§
    }
}

/**
 * åç«¯æœåŠ¡è·å–ç”¨æˆ·ä¿¡æ¯
 */
@Component
public class UserContextInterceptor extends HandlerInterceptorAdapter {
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                            Object handler) {
        String userId = request.getHeader("X-User-Id");
        String username = request.getHeader("X-Username");
        
        // è®¾ç½®åˆ°ä¸Šä¸‹æ–‡
        UserContext.setUserId(userId);
        UserContext.setUsername(username);
        
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                               Object handler, Exception ex) {
        UserContext.clear();
    }
}
```

#### 2. æœåŠ¡é—´è®¤è¯æ¨¡å¼ï¼ˆService-to-Service Authenticationï¼‰

```
Service A â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Service B
          Client Credentials
          (OAuth2)
```

**å®ç°ï¼š**

```java
/**
 * æœåŠ¡é—´è°ƒç”¨å®¢æˆ·ç«¯
 */
@Configuration
public class ServiceClientConfig {
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(OAuth2AuthorizedClientManager clientManager) {
        RestTemplate restTemplate = new RestTemplate();
        
        // æ·»åŠ OAuth2æ‹¦æˆªå™¨
        restTemplate.getInterceptors().add((request, body, execution) -> {
            OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest
                .withClientRegistrationId("service-client")
                .principal("service-account")
                .build();
            
            OAuth2AuthorizedClient client = clientManager.authorize(authorizeRequest);
            if (client != null) {
                request.getHeaders().setBearerAuth(
                    client.getAccessToken().getTokenValue()
                );
            }
            
            return execution.execute(request, body);
        });
        
        return restTemplate;
    }
    
    @Bean
    public OAuth2AuthorizedClientManager authorizedClientManager(
            ClientRegistrationRepository clientRegistrationRepository,
            OAuth2AuthorizedClientRepository authorizedClientRepository) {
        
        OAuth2AuthorizedClientProvider authorizedClientProvider =
            OAuth2AuthorizedClientProviderBuilder.builder()
                .clientCredentials()
                .build();
        
        DefaultOAuth2AuthorizedClientManager clientManager = 
            new DefaultOAuth2AuthorizedClientManager(
                clientRegistrationRepository,
                authorizedClientRepository
            );
        
        clientManager.setAuthorizedClientProvider(authorizedClientProvider);
        
        return clientManager;
    }
}
```

```yaml
# æœåŠ¡é…ç½®
spring:
  security:
    oauth2:
      client:
        registration:
          service-client:
            client-id: service-a
            client-secret: service-a-secret
            authorization-grant-type: client_credentials
            scope: service.read,service.write
        provider:
          auth-server:
            token-uri: http://auth-server:9000/oauth2/token
```

### åˆ†å¸ƒå¼è¿½è¸ªä¸å®‰å…¨

```java
/**
 * åœ¨åˆ†å¸ƒå¼è¿½è¸ªä¸­è®°å½•å®‰å…¨ä¿¡æ¯
 */
@Component
public class SecurityTracingAspect {
    
    @Autowired
    private Tracer tracer;
    
    @Around("@annotation(PreAuthorize)")
    public Object traceSecurityCheck(ProceedingJoinPoint joinPoint) throws Throwable {
        Span span = tracer.currentSpan();
        
        if (span != null) {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            if (auth != null) {
                span.tag("security.user", auth.getName());
                span.tag("security.authorities", 
                    auth.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")));
            }
        }
        
        return joinPoint.proceed();
    }
}
```

---

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. ç¼“å­˜è®¤è¯ä¿¡æ¯

```java
/**
 * ç¼“å­˜UserDetails
 */
@Service
public class CachedUserDetailsService implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Cacheable(value = "userDetails", key = "#username")
    @Override
    public UserDetails loadUserByUsername(String username) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        
        return buildUserDetails(user);
    }
    
    @CacheEvict(value = "userDetails", key = "#username")
    public void evictUserCache(String username) {
        // ç¼“å­˜å¤±æ•ˆï¼ˆç”¨æˆ·ä¿¡æ¯æ›´æ–°æ—¶è°ƒç”¨ï¼‰
    }
}
```

### 2. æ‰¹é‡æƒé™æ£€æŸ¥

```java
/**
 * æ‰¹é‡æƒé™æ£€æŸ¥
 */
@Service
public class BatchAuthorizationService {
    
    @Autowired
    private PermissionRepository permissionRepository;
    
    /**
     * æ‰¹é‡æ£€æŸ¥æƒé™
     */
    public Map<String, Boolean> checkPermissionsBatch(String userId, List<String> permissions) {
        // ä¸€æ¬¡æŸ¥è¯¢è·å–ç”¨æˆ·æ‰€æœ‰æƒé™
        Set<String> userPermissions = permissionRepository.findByUserId(userId);
        
        // æ‰¹é‡åˆ¤æ–­
        return permissions.stream()
            .collect(Collectors.toMap(
                permission -> permission,
                permission -> userPermissions.contains(permission)
            ));
    }
}
```

### 3. JWTç­¾åç®—æ³•é€‰æ‹©

```
æ€§èƒ½å¯¹æ¯”ï¼ˆç›¸å¯¹é€Ÿåº¦ï¼‰ï¼š
HMAC (HS256)ï¼š     â­â­â­â­â­ ï¼ˆæœ€å¿«ï¼‰
ECDSA (ES256):     â­â­â­â­
RSA (RS256):       â­â­â­

å®‰å…¨æ€§å¯¹æ¯”ï¼š
ECDSA (ES256):     â­â­â­â­â­ ï¼ˆç›¸åŒå¯†é’¥é•¿åº¦ä¸‹æœ€å®‰å…¨ï¼‰
RSA (RS256):       â­â­â­â­
HMAC (HS256):      â­â­â­ ï¼ˆéœ€è¦å®‰å…¨ä¼ è¾“å¯†é’¥ï¼‰

æ¨èï¼š
- å†…éƒ¨ç³»ç»Ÿï¼šHMAC (HS256)
- å…¬å¼€APIï¼šECDSA (ES256) æˆ– RSA (RS256)
```

### 4. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

```java
/**
 * ä¼˜åŒ–ç”¨æˆ·æƒé™æŸ¥è¯¢
 */
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // âŒ é”™è¯¯ï¼šN+1æŸ¥è¯¢é—®é¢˜
    @Query("SELECT u FROM User u WHERE u.username = :username")
    User findByUsername(String username);
    
    // âœ… æ­£ç¡®ï¼šä½¿ç”¨JOIN FETCHä¸€æ¬¡æ€§åŠ è½½
    @Query("SELECT u FROM User u " +
           "LEFT JOIN FETCH u.roles r " +
           "LEFT JOIN FETCH r.permissions " +
           "WHERE u.username = :username")
    User findByUsernameWithRolesAndPermissions(@Param("username") String username);
    
    // æˆ–ä½¿ç”¨EntityGraph
    @EntityGraph(attributePaths = {"roles", "roles.permissions"})
    Optional<User> findWithRolesByUsername(String username);
}
```

### 5. è¿æ¥æ± é…ç½®

```properties
# HikariCPé…ç½®
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# Redisè¿æ¥æ± 
spring.redis.lettuce.pool.max-active=20
spring.redis.lettuce.pool.max-idle=10
spring.redis.lettuce.pool.min-idle=5
```

---

## å®¡è®¡æ—¥å¿—ä¸ç›‘æ§

### å®¡è®¡æ—¥å¿—

```java
/**
 * å®¡è®¡äº‹ä»¶
 */
@Entity
@Table(name = "audit_logs")
@Data
public class AuditLog {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    
    private String action;  // LOGIN, LOGOUT, CREATE, UPDATE, DELETE
    
    private String resource;  // users, orders, etc.
    
    private String resourceId;
    
    private String ipAddress;
    
    private String userAgent;
    
    private boolean success;
    
    private String failureReason;
    
    @Column(columnDefinition = "TEXT")
    private String details;  // JSONæ ¼å¼çš„è¯¦ç»†ä¿¡æ¯
    
    @CreationTimestamp
    private LocalDateTime timestamp;
}

/**
 * å®¡è®¡æœåŠ¡
 */
@Service
@Async
public class AuditService {
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    /**
     * è®°å½•ç™»å½•äº‹ä»¶
     */
    public void logLogin(String username, String ipAddress, boolean success, String failureReason) {
        AuditLog log = new AuditLog();
        log.setUsername(username);
        log.setAction("LOGIN");
        log.setIpAddress(ipAddress);
        log.setSuccess(success);
        log.setFailureReason(failureReason);
        
        auditLogRepository.save(log);
    }
    
    /**
     * è®°å½•èµ„æºè®¿é—®
     */
    public void logResourceAccess(String username, String action, String resource, 
                                  String resourceId, boolean success) {
        AuditLog log = new AuditLog();
        log.setUsername(username);
        log.setAction(action);
        log.setResource(resource);
        log.setResourceId(resourceId);
        log.setSuccess(success);
        
        auditLogRepository.save(log);
    }
}

/**
 * å®¡è®¡åˆ‡é¢
 */
@Aspect
@Component
public class AuditAspect {
    
    @Autowired
    private AuditService auditService;
    
    @AfterReturning(
        pointcut = "@annotation(audited)",
        returning = "result"
    )
    public void auditSuccess(JoinPoint joinPoint, Audited audited, Object result) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth != null ? auth.getName() : "anonymous";
        
        auditService.logResourceAccess(
            username,
            audited.action(),
            audited.resource(),
            extractResourceId(joinPoint, result),
            true
        );
    }
    
    @AfterThrowing(
        pointcut = "@annotation(audited)",
        throwing = "ex"
    )
    public void auditFailure(JoinPoint joinPoint, Audited audited, Exception ex) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth != null ? auth.getName() : "anonymous";
        
        auditService.logResourceAccess(
            username,
            audited.action(),
            audited.resource(),
            null,
            false
        );
    }
}

/**
 * å®¡è®¡æ³¨è§£
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Audited {
    String action();
    String resource();
}

/**
 * ä½¿ç”¨ç¤ºä¾‹
 */
@Service
public class UserService {
    
    @Audited(action = "CREATE", resource = "users")
    public User createUser(User user) {
        return userRepository.save(user);
    }
    
    @Audited(action = "DELETE", resource = "users")
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
```

### ç›‘æ§æŒ‡æ ‡

```java
/**
 * å®‰å…¨ç›‘æ§æŒ‡æ ‡
 */
@Component
public class SecurityMetrics {
    
    private final Counter loginAttempts;
    private final Counter loginFailures;
    private final Counter loginSuccesses;
    private final Counter accessDenied;
    private final Gauge activeUsers;
    
    public SecurityMetrics(MeterRegistry registry) {
        this.loginAttempts = Counter.builder("security.login.attempts")
            .description("Total login attempts")
            .register(registry);
        
        this.loginFailures = Counter.builder("security.login.failures")
            .tag("reason", "invalid_credentials")
            .description("Failed login attempts")
            .register(registry);
        
        this.loginSuccesses = Counter.builder("security.login.successes")
            .description("Successful logins")
            .register(registry);
        
        this.accessDenied = Counter.builder("security.access.denied")
            .description("Access denied events")
            .register(registry);
        
        this.activeUsers = Gauge.builder("security.users.active", this, SecurityMetrics::getActiveUserCount)
            .description("Number of active users")
            .register(registry);
    }
    
    public void recordLoginAttempt() {
        loginAttempts.increment();
    }
    
    public void recordLoginSuccess() {
        loginSuccesses.increment();
    }
    
    public void recordLoginFailure() {
        loginFailures.increment();
    }
    
    public void recordAccessDenied() {
        accessDenied.increment();
    }
    
    private double getActiveUserCount() {
        // å®ç°æ´»è·ƒç”¨æˆ·æ•°ç»Ÿè®¡
        return sessionRegistry.getAllPrincipals().size();
    }
}
```

### å®‰å…¨å‘Šè­¦

```java
/**
 * å®‰å…¨å‘Šè­¦æœåŠ¡
 */
@Service
public class SecurityAlertService {
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    /**
     * æ£€æµ‹æš´åŠ›ç ´è§£æ”»å‡»
     */
    @Scheduled(fixedRate = 60000)  // æ¯åˆ†é’Ÿ
    public void detectBruteForceAttacks() {
        LocalDateTime oneMinuteAgo = LocalDateTime.now().minusMinutes(1);
        
        // æŸ¥æ‰¾1åˆ†é’Ÿå†…å¤±è´¥æ¬¡æ•°è¶…è¿‡5æ¬¡çš„IP
        List<Map<String, Object>> suspiciousIps = auditLogRepository
            .findFailedLoginsByIpSince(oneMinuteAgo, 5);
        
        for (Map<String, Object> entry : suspiciousIps) {
            String ipAddress = (String) entry.get("ipAddress");
            Long failureCount = (Long) entry.get("failureCount");
            
            notificationService.sendAlert(
                "å¯ç–‘çš„æš´åŠ›ç ´è§£æ”»å‡»",
                String.format("IP %s åœ¨1åˆ†é’Ÿå†…å°è¯•ç™»å½•å¤±è´¥ %d æ¬¡", ipAddress, failureCount)
            );
            
            // å¯ä»¥è€ƒè™‘è‡ªåŠ¨å°ç¦IP
            // ipBlocklistService.blockIp(ipAddress, Duration.ofHours(1));
        }
    }
    
    /**
     * æ£€æµ‹å¼‚å¸¸è®¿é—®æ¨¡å¼
     */
    @Scheduled(fixedRate = 300000)  // æ¯5åˆ†é’Ÿ
    public void detectAnomalousAccess() {
        LocalDateTime fiveMinutesAgo = LocalDateTime.now().minusMinutes(5);
        
        // æ£€æµ‹çŸ­æ—¶é—´å†…å¤§é‡èµ„æºè®¿é—®
        List<Map<String, Object>> heavyUsers = auditLogRepository
            .findUsersWithHighActivitySince(fiveMinutesAgo, 100);
        
        for (Map<String, Object> entry : heavyUsers) {
            String username = (String) entry.get("username");
            Long requestCount = (Long) entry.get("requestCount");
            
            notificationService.sendAlert(
                "å¼‚å¸¸è®¿é—®æ¨¡å¼",
                String.format("ç”¨æˆ· %s åœ¨5åˆ†é’Ÿå†…å‘èµ·äº† %d æ¬¡è¯·æ±‚", username, requestCount)
            );
        }
    }
}
```

---

## å®‰å…¨æœ€ä½³å®è·µæ±‡æ€»

### 1. å¯†ç å®‰å…¨

```java
/**
 * å¯†ç å®‰å…¨æœ€ä½³å®è·µ
 */
public class PasswordSecurityBestPractices {
    
    // âœ… ä½¿ç”¨å¼ºåŠ å¯†ç®—æ³•
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);  // strength 12
    }
    
    // âœ… å¯†ç å¤æ‚åº¦éªŒè¯
    public boolean validatePasswordStrength(String password) {
        return password.length() >= 12 &&
               password.matches(".*[A-Z].*") &&
               password.matches(".*[a-z].*") &&
               password.matches(".*[0-9].*") &&
               password.matches(".*[!@#$%^&*].*");
    }
    
    // âœ… å¯†ç å†å²è®°å½•ï¼ˆé˜²æ­¢é‡ç”¨ï¼‰
    public boolean checkPasswordHistory(String userId, String newPassword) {
        List<String> previousPasswords = passwordHistoryRepository
            .findLastNPasswords(userId, 5);
        
        return previousPasswords.stream()
            .noneMatch(oldPassword -> 
                passwordEncoder.matches(newPassword, oldPassword));
    }
    
    // âœ… å¼ºåˆ¶å®šæœŸæ›´æ¢å¯†ç 
    public boolean isPasswordExpired(User user) {
        return user.getPasswordChangedAt()
            .isBefore(LocalDateTime.now().minusDays(90));
    }
}
```

### 2. Tokenå®‰å…¨

```java
/**
 * Tokenå®‰å…¨æœ€ä½³å®è·µ
 */
public class TokenSecurityBestPractices {
    
    // âœ… çŸ­æœŸAccess Token + é•¿æœŸRefresh Token
    private static final long ACCESS_TOKEN_VALIDITY = 15 * 60 * 1000;   // 15åˆ†é’Ÿ
    private static final long REFRESH_TOKEN_VALIDITY = 7 * 24 * 60 * 60 * 1000;  // 7å¤©
    
    // âœ… Tokenè½®æ¢ï¼ˆæ¯æ¬¡åˆ·æ–°æ—¶ç”Ÿæˆæ–°çš„Refresh Tokenï¼‰
    public TokenPair refreshToken(String refreshToken) {
        if (!validateRefreshToken(refreshToken)) {
            throw new InvalidTokenException();
        }
        
        // ç”Ÿæˆæ–°çš„Tokenå¯¹
        String newAccessToken = generateAccessToken(user);
        String newRefreshToken = generateRefreshToken(user);
        
        // åºŸå¼ƒæ—§çš„Refresh Token
        refreshTokenRepository.deleteByToken(refreshToken);
        refreshTokenRepository.save(newRefreshToken);
        
        return new TokenPair(newAccessToken, newRefreshToken);
    }
    
    // âœ… Tokené»‘åå•ï¼ˆæå‰åŠé”€ï¼‰
    public void revokeToken(String token) {
        Claims claims = parseToken(token);
        long expirationTime = claims.getExpiration().getTime();
        long ttl = expirationTime - System.currentTimeMillis();
        
        if (ttl > 0) {
            redisTemplate.opsForValue().set(
                "blacklist:" + token,
                "1",
                ttl,
                TimeUnit.MILLISECONDS
            );
        }
    }
}
```

### 3. APIå®‰å…¨

```java
/**
 * APIå®‰å…¨æœ€ä½³å®è·µ
 */
@Configuration
public class ApiSecurityConfig {
    
    @Bean
    public SecurityFilterChain apiSecurityFilterChain(HttpSecurity http) throws Exception {
        http
            // âœ… HTTPS Only
            .requiresChannel(channel -> channel
                .anyRequest().requiresSecure()
            )
            
            // âœ… CORSé…ç½®
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            
            // âœ… å®‰å…¨å“åº”å¤´
            .headers(headers -> headers
                .contentSecurityPolicy("default-src 'self'")
                .frameOptions().deny()
                .xssProtection().enable()
                .contentTypeOptions().enable()
                .httpStrictTransportSecurity()
                    .includeSubDomains(true)
                    .maxAgeInSeconds(31536000)
            )
            
            // âœ… é€Ÿç‡é™åˆ¶
            .addFilterBefore(rateLimitFilter(), UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    // âœ… CORSé…ç½®
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("https://trusted-domain.com"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
        configuration.setExposedHeaders(Arrays.asList("X-Total-Count"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
```

### 4. æ•°æ®å®‰å…¨

```java
/**
 * æ•°æ®å®‰å…¨æœ€ä½³å®è·µ
 */
public class DataSecurityBestPractices {
    
    // âœ… æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
    @Component
    public class DataEncryptionService {
        
        private final Cipher cipher;
        private final SecretKey secretKey;
        
        public String encrypt(String plaintext) {
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] encrypted = cipher.doFinal(plaintext.getBytes());
            return Base64.getEncoder().encodeToString(encrypted);
        }
        
        public String decrypt(String ciphertext) {
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            byte[] decoded = Base64.getDecoder().decode(ciphertext);
            byte[] decrypted = cipher.doFinal(decoded);
            return new String(decrypted);
        }
    }
    
    // âœ… æ•°æ®è„±æ•
    public String maskSensitiveData(String data, DataType type) {
        switch (type) {
            case PHONE:
                return data.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
            case EMAIL:
                return data.replaceAll("(^\\w{1,3}).*(@.*)", "$1***$2");
            case ID_CARD:
                return data.replaceAll("(\\d{6})\\d{8}(\\d{4})", "$1********$2");
            default:
                return data;
        }
    }
    
    // âœ… SQLæ³¨å…¥é˜²æŠ¤
    @Repository
    public interface UserRepository extends JpaRepository<User, Long> {
        // ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
        @Query("SELECT u FROM User u WHERE u.username = :username")
        User findByUsername(@Param("username") String username);
        
        // âŒ ä¸è¦ä½¿ç”¨å­—ç¬¦ä¸²æ‹¼æ¥
        // @Query("SELECT u FROM User u WHERE u.username = '" + username + "'")
    }
}
```

### 5. æ—¥å¿—å®‰å…¨

```java
/**
 * æ—¥å¿—å®‰å…¨æœ€ä½³å®è·µ
 */
@Component
public class SecureLogging {
    
    private static final Logger logger = LoggerFactory.getLogger(SecureLogging.class);
    
    // âœ… ä¸è¦è®°å½•æ•æ„Ÿä¿¡æ¯
    public void logUserAction(User user, String action) {
        logger.info("User action: user={}, action={}", 
            user.getUsername(),  // âœ… OK
            action);
        
        // âŒ ä¸è¦è®°å½•å¯†ç ã€Tokenç­‰
        // logger.info("Password: {}", user.getPassword());
        // logger.info("Token: {}", token);
    }
    
    // âœ… ä½¿ç”¨æ—¥å¿—çº§åˆ«
    public void logSecurityEvent(SecurityEvent event) {
        switch (event.getSeverity()) {
            case CRITICAL:
                logger.error("Security event: {}", event);
                break;
            case WARNING:
                logger.warn("Security event: {}", event);
                break;
            case INFO:
                logger.info("Security event: {}", event);
                break;
        }
    }
    
    // âœ… ç»“æ„åŒ–æ—¥å¿—
    public void logStructured(String username, String action, boolean success) {
        logger.info("action={}, username={}, success={}, timestamp={}", 
            action, username, success, Instant.now());
    }
}
```

---

## æ€»ç»“

æœ¬ç« ä»‹ç»äº†è®¤è¯æˆæƒçš„é«˜çº§ä¸»é¢˜ï¼š

1. **å¤šç§Ÿæˆ·è®¤è¯**ï¼šæ•°æ®éš”ç¦»ã€ç§Ÿæˆ·è¯†åˆ«ã€ä¸Šä¸‹æ–‡ç®¡ç†
2. **åˆ†å¸ƒå¼ä¼šè¯**ï¼šRedis Sessionã€Sessionç›‘æ§ã€é›†ç¾¤ç®¡ç†
3. **å¾®æœåŠ¡å®‰å…¨**ï¼šç½‘å…³è®¤è¯ã€æœåŠ¡é—´è°ƒç”¨ã€åˆ†å¸ƒå¼è¿½è¸ª
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜ç­–ç•¥ã€æ‰¹é‡å¤„ç†ã€æ•°æ®åº“ä¼˜åŒ–
5. **å®¡è®¡ç›‘æ§**ï¼šæ—¥å¿—è®°å½•ã€æŒ‡æ ‡ç›‘æ§ã€å®‰å…¨å‘Šè­¦
6. **æœ€ä½³å®è·µ**ï¼šå¯†ç ã€Tokenã€APIã€æ•°æ®ã€æ—¥å¿—å®‰å…¨

**å…³é”®è¦ç‚¹ï¼š**
- å®‰å…¨æ˜¯ç³»ç»Ÿæ€§å·¥ç¨‹ï¼Œéœ€è¦å¤šå±‚é˜²æŠ¤
- æ€§èƒ½å’Œå®‰å…¨éœ€è¦å¹³è¡¡
- æŒç»­ç›‘æ§å’Œå®¡è®¡è‡³å…³é‡è¦
- éµå¾ªæœ€å°æƒé™åŸåˆ™
- å®šæœŸå®‰å…¨å®¡æŸ¥å’Œæ›´æ–°

**ç»§ç»­å­¦ä¹ ï¼š**
- [è¿”å›é¦–é¡µï¼šè®¤è¯æˆæƒåŸºç¡€](./01-è®¤è¯æˆæƒåŸºç¡€.md)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Spring Securityå®˜æ–¹æ–‡æ¡£](https://docs.spring.io/spring-security/reference/)

---

## å®Œæ•´å­¦ä¹ è·¯å¾„

1. [è®¤è¯æˆæƒåŸºç¡€](./01-è®¤è¯æˆæƒåŸºç¡€.md) - æ ¸å¿ƒæ¦‚å¿µ
2. [è®¤è¯åè®®ä¸æ ‡å‡†](./02-è®¤è¯åè®®ä¸æ ‡å‡†.md) - OAuth2ã€JWTã€SSO
3. [Javaè®¤è¯æ¡†æ¶å¯¹æ¯”](./03-Javaè®¤è¯æ¡†æ¶å¯¹æ¯”.md) - æ¡†æ¶é€‰å‹
4. [Spring Securityæ ¸å¿ƒæ¶æ„](./04-SpringSecurityæ ¸å¿ƒæ¶æ„.md) - æ¶æ„åŸç†
5. [Spring Securityå®æˆ˜é…ç½®](./05-SpringSecurityå®æˆ˜é…ç½®.md) - å®è·µé…ç½®
6. [Spring Security OAuth2é›†æˆ](./06-SpringSecurity-OAuth2.md) - OAuth2å®ç°
7. [ä»£ç ç¤ºä¾‹é›†](./07-ä»£ç ç¤ºä¾‹é›†.md) - å®Œæ•´ç¤ºä¾‹
8. [é«˜çº§ä¸»é¢˜ä¸æœ€ä½³å®è·µ](./08-é«˜çº§ä¸»é¢˜ä¸æœ€ä½³å®è·µ.md) - æœ¬ç« 

**æ­å–œä½ å®Œæˆè®¤è¯æˆæƒçŸ¥è¯†ä½“ç³»çš„å­¦ä¹ ï¼** ğŸ‰

