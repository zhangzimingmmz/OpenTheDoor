# å¹¶å‘é›†åˆ (Concurrent Collections)

> æ·±å…¥ç†è§£ConcurrentHashMapã€BlockingQueueã€CopyOnWriteArrayListç­‰å¹¶å‘é›†åˆçš„å®ç°åŸç†å’Œä½¿ç”¨åœºæ™¯

## ç›®å½•
- [1. ä¸ºä»€ä¹ˆéœ€è¦å¹¶å‘é›†åˆ](#1-ä¸ºä»€ä¹ˆéœ€è¦å¹¶å‘é›†åˆ)
- [2. ConcurrentHashMap](#2-concurrenthashmap)
- [3. BlockingQueue](#3-blockingqueue)
- [4. CopyOnWriteArrayList](#4-copyonwritearraylist)
- [5. ConcurrentLinkedQueue](#5-concurrentlinkedqueue)
- [6. å¹¶å‘é›†åˆå¯¹æ¯”](#6-å¹¶å‘é›†åˆå¯¹æ¯”)
- [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
- [8. é¢è¯•é«˜é¢‘é—®é¢˜](#8-é¢è¯•é«˜é¢‘é—®é¢˜)

---

## 1. ä¸ºä»€ä¹ˆéœ€è¦å¹¶å‘é›†åˆ (Why Concurrent Collections?)

### 1.1 ä¼ ç»Ÿé›†åˆçš„çº¿ç¨‹å®‰å…¨é—®é¢˜

```java
/**
 * HashMapçº¿ç¨‹ä¸å®‰å…¨ç¤ºä¾‹
 * HashMap Thread Safety Problem
 */
public class HashMapUnsafe {
    public static void main(String[] args) throws InterruptedException {
        Map<String, Integer> map = new HashMap<>();
        
        // å¤šçº¿ç¨‹å¹¶å‘put
        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    map.put("key" + j, j); // å¯èƒ½ä¸¢å¤±æ•°æ®æˆ–æ­»å¾ªç¯
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        // ç»“æœå¯èƒ½å°äº10000ï¼Œç”šè‡³å¯èƒ½æ­»å¾ªç¯
        System.out.println("Mapå¤§å°: " + map.size());
    }
}
```

**é—®é¢˜ï¼š**
1. **æ•°æ®ä¸¢å¤±** - å¹¶å‘putå¯èƒ½å¯¼è‡´æ•°æ®è¦†ç›–
2. **æ­»å¾ªç¯** - JDK 1.7åŠä¹‹å‰ç‰ˆæœ¬ï¼Œå¹¶å‘æ‰©å®¹å¯èƒ½å¯¼è‡´æ­»å¾ªç¯
3. **æ•°æ®ä¸ä¸€è‡´** - è¯»å–åˆ°ä¸­é—´çŠ¶æ€çš„æ•°æ®

### 1.2 è§£å†³æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | å®ç° | æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **synchronizedåŒ…è£…** | `Collections.synchronizedMap()` | ä½ | ä½å¹¶å‘åœºæ™¯ |
| **Hashtable** | æ‰€æœ‰æ–¹æ³•synchronized | ä½ | å·²è¿‡æ—¶ï¼Œä¸æ¨è |
| **ConcurrentHashMap** | CAS + synchronized | é«˜ | é«˜å¹¶å‘åœºæ™¯ï¼ˆæ¨èï¼‰ |

### 1.3 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

åœ¨ç®—åŠ›å¹³å°çš„ç»“ç®—ç³»ç»Ÿä¸­ï¼Œéœ€è¦çº¿ç¨‹å®‰å…¨çš„Mapå­˜å‚¨ç”¨æˆ·é’±åŒ…ä¿¡æ¯ï¼š

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„å¹¶å‘é›†åˆåº”ç”¨
 * Concurrent Collections in Computing Platform
 */
public class PlatformConcurrentCollections {
    
    // ç”¨æˆ·é’±åŒ…ä½™é¢ï¼šä½¿ç”¨ConcurrentHashMap
    private ConcurrentHashMap<Long, AtomicLong> walletMap = new ConcurrentHashMap<>();
    
    // ä»»åŠ¡çŠ¶æ€é˜Ÿåˆ—ï¼šä½¿ç”¨BlockingQueue
    private BlockingQueue<TaskStatus> taskStatusQueue = new LinkedBlockingQueue<>();
    
    // èŠ‚ç‚¹ä¿¡æ¯ç¼“å­˜ï¼šä½¿ç”¨CopyOnWriteArrayListï¼ˆè¯»å¤šå†™å°‘ï¼‰
    private CopyOnWriteArrayList<NodeInfo> nodeCache = new CopyOnWriteArrayList<>();
    
    // çº¿ç¨‹å®‰å…¨çš„æ‰£è´¹æ“ä½œ
    public boolean deduct(Long userId, Long amount) {
        AtomicLong balance = walletMap.computeIfAbsent(
            userId, k -> new AtomicLong(0)
        );
        
        return balance.updateAndGet(current -> {
            if (current >= amount) {
                return current - amount;
            }
            throw new InsufficientBalanceException();
        }) >= 0;
    }
}
```

---

## 2. ConcurrentHashMap (ConcurrentHashMap)

### 2.1 æ ¸å¿ƒç‰¹ç‚¹

| ç‰¹æ€§ | JDK 1.7 | JDK 1.8+ |
|------|---------|----------|
| **æ•°æ®ç»“æ„** | Segment + HashEntryæ•°ç»„ | Nodeæ•°ç»„ + é“¾è¡¨/çº¢é»‘æ ‘ |
| **é”æœºåˆ¶** | åˆ†æ®µé”ï¼ˆSegmentï¼‰ | CAS + synchronized |
| **å¹¶å‘åº¦** | Segmentæ•°é‡ï¼ˆé»˜è®¤16ï¼‰ | æ›´é«˜ï¼ˆæ¥è¿‘æ— é”ï¼‰ |
| **æ€§èƒ½** | è¾ƒå¥½ | æ›´å¥½ |

### 2.2 JDK 1.8å®ç°åŸç†

#### æ•°æ®ç»“æ„

```java
/**
 * ConcurrentHashMapæ ¸å¿ƒæ•°æ®ç»“æ„ï¼ˆJDK 1.8ï¼‰
 * Core Data Structure (JDK 1.8)
 */
public class ConcurrentHashMap<K,V> {
    // Nodeæ•°ç»„ï¼ˆç±»ä¼¼HashMapçš„tableï¼‰
    transient volatile Node<K,V>[] table;
    
    // æ‰©å®¹æ—¶çš„ä¸´æ—¶æ•°ç»„
    private transient volatile Node<K,V>[] nextTable;
    
    // æ§åˆ¶æ ‡è¯†ç¬¦
    private transient volatile int sizeCtl;
    
    // NodeèŠ‚ç‚¹ï¼ˆé“¾è¡¨èŠ‚ç‚¹ï¼‰
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        volatile V val;
        volatile Node<K,V> next;
    }
    
    // TreeNodeï¼ˆçº¢é»‘æ ‘èŠ‚ç‚¹ï¼‰
    static final class TreeNode<K,V> extends Node<K,V> {
        TreeNode<K,V> parent;
        TreeNode<K,V> left;
        TreeNode<K,V> right;
    }
}
```

#### æ ¸å¿ƒæ–¹æ³•ï¼šput()

```java
/**
 * ConcurrentHashMap.put()æ–¹æ³•æ ¸å¿ƒé€»è¾‘
 * Core Logic of put() Method
 */
public V put(K key, V value) {
    return putVal(key, value, false);
}

final V putVal(K key, V value, boolean onlyIfAbsent) {
    // 1. è®¡ç®—hashå€¼
    int hash = spread(key.hashCode());
    int binCount = 0;
    
    // 2. è‡ªæ—‹æ’å…¥
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        
        // 2.1 å¦‚æœtableæœªåˆå§‹åŒ–ï¼Œå…ˆåˆå§‹åŒ–
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        
        // 2.2 å¦‚æœæ¡¶ä¸ºç©ºï¼ŒCASæ’å…¥
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                break;
        }
        
        // 2.3 å¦‚æœæ­£åœ¨æ‰©å®¹ï¼Œå¸®åŠ©æ‰©å®¹
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        
        // 2.4 æ¡¶ä¸ä¸ºç©ºï¼Œsynchronizedé”ä½é“¾è¡¨å¤´èŠ‚ç‚¹
        else {
            V oldVal = null;
            synchronized (f) {
                // å†æ¬¡æ£€æŸ¥ï¼ˆåŒé‡æ£€æŸ¥ï¼‰
                if (tabAt(tab, i) == f) {
                    // é“¾è¡¨æ’å…¥
                    if (fh >= 0) {
                        // ... é“¾è¡¨æ’å…¥é€»è¾‘
                    }
                    // çº¢é»‘æ ‘æ’å…¥
                    else if (f instanceof TreeBin) {
                        // ... çº¢é»‘æ ‘æ’å…¥é€»è¾‘
                    }
                }
            }
        }
    }
    
    // 3. æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
    if (binCount != 0) {
        if (binCount >= TREEIFY_THRESHOLD)
            treeifyBin(tab, i);
    }
    return null;
}
```

**å…³é”®ç‚¹ï¼š**
1. **CASæ’å…¥** - æ¡¶ä¸ºç©ºæ—¶ï¼Œä½¿ç”¨CASæ— é”æ’å…¥
2. **synchronizedé”** - æ¡¶ä¸ä¸ºç©ºæ—¶ï¼Œé”ä½é“¾è¡¨å¤´èŠ‚ç‚¹ï¼ˆç»†ç²’åº¦é”ï¼‰
3. **åŒé‡æ£€æŸ¥** - synchronizedå†…éƒ¨å†æ¬¡æ£€æŸ¥ï¼Œé˜²æ­¢å¹¶å‘é—®é¢˜

#### æ ¸å¿ƒæ–¹æ³•ï¼šget()

```java
/**
 * ConcurrentHashMap.get()æ–¹æ³•
 * get() Method
 */
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    int h = spread(key.hashCode());
    
    // 1. tableä¸ä¸ºç©ºä¸”æ¡¶ä¸ä¸ºç©º
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        
        // 2. æ£€æŸ¥ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        
        // 3. hashå€¼ä¸ºè´Ÿï¼Œè¯´æ˜æ˜¯çº¢é»‘æ ‘æˆ–æ­£åœ¨æ‰©å®¹
        else if (eh < 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        
        // 4. éå†é“¾è¡¨
        while ((e = e.next) != null) {
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```

**ç‰¹ç‚¹ï¼š** get()æ“ä½œ**æ— é”**ï¼Œæ€§èƒ½é«˜ï¼

### 2.3 ConcurrentHashMap vs HashMap vs Hashtable

| ç‰¹æ€§ | HashMap | Hashtable | ConcurrentHashMap |
|------|---------|-----------|-------------------|
| **çº¿ç¨‹å®‰å…¨** | âŒ | âœ… | âœ… |
| **é”æœºåˆ¶** | æ—  | synchronizedï¼ˆæ–¹æ³•çº§ï¼‰ | CAS + synchronizedï¼ˆç»†ç²’åº¦ï¼‰ |
| **æ€§èƒ½** | é«˜ | ä½ | é«˜ |
| **nullé”®å€¼** | å…è®¸ | ä¸å…è®¸ | ä¸å…è®¸ |
| **è¿­ä»£å™¨** | fail-fast | fail-fast | å¼±ä¸€è‡´æ€§ |
| **é€‚ç”¨åœºæ™¯** | å•çº¿ç¨‹ | å·²è¿‡æ—¶ | é«˜å¹¶å‘ï¼ˆæ¨èï¼‰ |

### 2.4 ä½¿ç”¨ç¤ºä¾‹

```java
/**
 * ConcurrentHashMapä½¿ç”¨ç¤ºä¾‹
 * ConcurrentHashMap Usage Example
 */
public class ConcurrentHashMapDemo {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // 1. åŸºæœ¬æ“ä½œ
        map.put("key1", 1);
        map.get("key1");
        map.remove("key1");
        
        // 2. çº¿ç¨‹å®‰å…¨çš„putIfAbsent
        map.putIfAbsent("key2", 2); // å¦‚æœä¸å­˜åœ¨æ‰put
        
        // 3. åŸå­æ“ä½œï¼šcomputeIfAbsent
        map.computeIfAbsent("key3", k -> {
            // å¦‚æœkey3ä¸å­˜åœ¨ï¼Œè®¡ç®—å¹¶put
            return 3;
        });
        
        // 4. åŸå­æ“ä½œï¼šcomputeIfPresent
        map.computeIfPresent("key3", (k, v) -> {
            // å¦‚æœkey3å­˜åœ¨ï¼Œæ›´æ–°å€¼
            return v + 1;
        });
        
        // 5. éå†ï¼ˆå¼±ä¸€è‡´æ€§ï¼‰
        map.forEach((k, v) -> {
            System.out.println(k + " = " + v);
        });
    }
}
```

---

## 3. BlockingQueue (BlockingQueue)

### 3.1 æ ¸å¿ƒç‰¹ç‚¹

**BlockingQueueï¼ˆé˜»å¡é˜Ÿåˆ—ï¼‰**æ˜¯ä¸€ä¸ªæ”¯æŒé˜»å¡æ“ä½œçš„é˜Ÿåˆ—æ¥å£ï¼Œå¸¸ç”¨äºç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ã€‚

**æ ¸å¿ƒæ–¹æ³•ï¼š**

| æ“ä½œ | æŠ›å‡ºå¼‚å¸¸ | è¿”å›ç‰¹æ®Šå€¼ | é˜»å¡ | è¶…æ—¶ |
|------|---------|-----------|------|------|
| **æ’å…¥** | add(e) | offer(e) | put(e) | offer(e, time, unit) |
| **ç§»é™¤** | remove() | poll() | take() | poll(time, unit) |
| **æ£€æŸ¥** | element() | peek() | - | - |

### 3.2 å¸¸ç”¨å®ç°ç±»

#### ArrayBlockingQueueï¼ˆæ•°ç»„é˜»å¡é˜Ÿåˆ—ï¼‰

```java
/**
 * ArrayBlockingQueueï¼šæœ‰ç•Œé˜»å¡é˜Ÿåˆ—
 * ArrayBlockingQueue: Bounded Blocking Queue
 */
BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);

// ç”Ÿäº§è€…
queue.put("item"); // é˜»å¡ç›´åˆ°æœ‰ç©ºé—´

// æ¶ˆè´¹è€…
String item = queue.take(); // é˜»å¡ç›´åˆ°æœ‰å…ƒç´ 
```

**ç‰¹ç‚¹ï¼š**
- æœ‰ç•Œé˜Ÿåˆ—ï¼ˆéœ€è¦æŒ‡å®šå®¹é‡ï¼‰
- åŸºäºæ•°ç»„å®ç°
- ä½¿ç”¨ReentrantLockå®ç°é˜»å¡

#### LinkedBlockingQueueï¼ˆé“¾è¡¨é˜»å¡é˜Ÿåˆ—ï¼‰

```java
/**
 * LinkedBlockingQueueï¼šå¯é€‰æœ‰ç•Œé˜»å¡é˜Ÿåˆ—
 * LinkedBlockingQueue: Optional Bounded Blocking Queue
 */
// æ— ç•Œé˜Ÿåˆ—
BlockingQueue<String> unboundedQueue = new LinkedBlockingQueue<>();

// æœ‰ç•Œé˜Ÿåˆ—
BlockingQueue<String> boundedQueue = new LinkedBlockingQueue<>(100);
```

**ç‰¹ç‚¹ï¼š**
- å¯ä»¥æ˜¯æœ‰ç•Œæˆ–æ— ç•Œ
- åŸºäºé“¾è¡¨å®ç°
- ååé‡é€šå¸¸é«˜äºArrayBlockingQueue

#### SynchronousQueueï¼ˆåŒæ­¥é˜Ÿåˆ—ï¼‰

```java
/**
 * SynchronousQueueï¼šåŒæ­¥é˜Ÿåˆ—ï¼ˆä¸å­˜å‚¨å…ƒç´ ï¼‰
 * SynchronousQueue: Synchronous Queue
 */
BlockingQueue<String> queue = new SynchronousQueue<>();

// ç”Ÿäº§è€…ï¼šå¿…é¡»ç­‰å¾…æ¶ˆè´¹è€…å–èµ°
new Thread(() -> {
    try {
        queue.put("item"); // é˜»å¡ç›´åˆ°æœ‰æ¶ˆè´¹è€…
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}).start();

// æ¶ˆè´¹è€…ï¼šå¿…é¡»ç­‰å¾…ç”Ÿäº§è€…æ”¾å…¥
new Thread(() -> {
    try {
        String item = queue.take(); // é˜»å¡ç›´åˆ°æœ‰ç”Ÿäº§è€…
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}).start();
```

**ç‰¹ç‚¹ï¼š**
- ä¸å­˜å‚¨å…ƒç´ 
- æ¯ä¸ªputå¿…é¡»ç­‰å¾…take
- ç”¨äºç›´æ¥ä¼ é€’ä»»åŠ¡

#### PriorityBlockingQueueï¼ˆä¼˜å…ˆçº§é˜»å¡é˜Ÿåˆ—ï¼‰

```java
/**
 * PriorityBlockingQueueï¼šä¼˜å…ˆçº§é˜»å¡é˜Ÿåˆ—
 * PriorityBlockingQueue: Priority Blocking Queue
 */
BlockingQueue<Integer> queue = new PriorityBlockingQueue<>();

queue.put(5);
queue.put(1);
queue.put(3);

// æŒ‰ä¼˜å…ˆçº§å–å‡ºï¼š1, 3, 5
while (!queue.isEmpty()) {
    System.out.println(queue.take());
}
```

**ç‰¹ç‚¹ï¼š**
- æ— ç•Œé˜Ÿåˆ—
- åŸºäºå †å®ç°
- å…ƒç´ å¿…é¡»å®ç°Comparableæ¥å£

### 3.3 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

```java
/**
 * ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ç¤ºä¾‹
 * Producer-Consumer Pattern Example
 */
public class ProducerConsumerDemo {
    private BlockingQueue<String> queue = new LinkedBlockingQueue<>(10);
    
    // ç”Ÿäº§è€…
    class Producer implements Runnable {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 100; i++) {
                    String item = "item-" + i;
                    queue.put(item); // é˜»å¡ç›´åˆ°æœ‰ç©ºé—´
                    System.out.println("ç”Ÿäº§: " + item);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    // æ¶ˆè´¹è€…
    class Consumer implements Runnable {
        @Override
        public void run() {
            try {
                while (true) {
                    String item = queue.take(); // é˜»å¡ç›´åˆ°æœ‰å…ƒç´ 
                    System.out.println("æ¶ˆè´¹: " + item);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    public void start() {
        new Thread(new Producer()).start();
        new Thread(new Consumer()).start();
    }
}
```

### 3.4 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„BlockingQueueåº”ç”¨
 * BlockingQueue in Computing Platform
 */
public class PlatformBlockingQueue {
    
    // ä»»åŠ¡çŠ¶æ€é˜Ÿåˆ—ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼
    private BlockingQueue<TaskStatus> taskStatusQueue = new LinkedBlockingQueue<>(1000);
    
    // ç”Ÿäº§è€…ï¼šå®šæ—¶ä»»åŠ¡é‡‡é›†Nomadä»»åŠ¡çŠ¶æ€
    @Scheduled(fixedRate = 5000)
    public void produceTaskStatus() {
        List<TaskStatus> statuses = nomadClient.getTaskStatuses();
        for (TaskStatus status : statuses) {
            try {
                taskStatusQueue.put(status); // é˜»å¡ç›´åˆ°æœ‰ç©ºé—´
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    // æ¶ˆè´¹è€…ï¼šæ‰¹é‡æ›´æ–°æ•°æ®åº“
    @PostConstruct
    public void consumeTaskStatus() {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        executor.submit(() -> {
            List<TaskStatus> batch = new ArrayList<>();
            while (true) {
                try {
                    // æ‰¹é‡è·å–ï¼ˆæœ€å¤š100ä¸ªï¼‰
                    taskStatusQueue.drainTo(batch, 100);
                    if (!batch.isEmpty()) {
                        batchUpdateDatabase(batch);
                        batch.clear();
                    } else {
                        // é˜Ÿåˆ—ä¸ºç©ºï¼Œç­‰å¾…
                        TaskStatus status = taskStatusQueue.take();
                        batch.add(status);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
    }
}
```

---

## 4. CopyOnWriteArrayList (CopyOnWriteArrayList)

### 4.1 æ ¸å¿ƒç‰¹ç‚¹

**CopyOnWriteArrayListï¼ˆå†™æ—¶å¤åˆ¶åˆ—è¡¨ï¼‰**ï¼šè¯»æ“ä½œæ— é”ï¼Œå†™æ“ä½œæ—¶å¤åˆ¶æ•´ä¸ªæ•°ç»„ã€‚

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **è¯»æ“ä½œ** | æ— é”ï¼Œé«˜æ€§èƒ½ |
| **å†™æ“ä½œ** | åŠ é”ï¼Œå¤åˆ¶æ•´ä¸ªæ•°ç»„ |
| **é€‚ç”¨åœºæ™¯** | è¯»å¤šå†™å°‘ |
| **å†…å­˜æ¶ˆè€—** | å†™æ“ä½œæ—¶å†…å­˜æ¶ˆè€—å¤§ |

### 4.2 å®ç°åŸç†

```java
/**
 * CopyOnWriteArrayListæ ¸å¿ƒå®ç°
 * Core Implementation
 */
public class CopyOnWriteArrayList<E> {
    private transient volatile Object[] array;
    final transient ReentrantLock lock = new ReentrantLock();
    
    // è¯»æ“ä½œï¼šæ— é”
    public E get(int index) {
        return get(getArray(), index);
    }
    
    final Object[] getArray() {
        return array; // ç›´æ¥è¿”å›æ•°ç»„å¼•ç”¨
    }
    
    // å†™æ“ä½œï¼šåŠ é” + å¤åˆ¶
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            // å¤åˆ¶æ•°ç»„
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            // æ›¿æ¢æ•°ç»„å¼•ç”¨
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
}
```

**å…³é”®ç‚¹ï¼š**
1. **volatileæ•°ç»„** - ä¿è¯å¯è§æ€§
2. **å†™æ—¶å¤åˆ¶** - å†™æ“ä½œæ—¶åˆ›å»ºæ–°æ•°ç»„
3. **åŸå­æ›¿æ¢** - ä½¿ç”¨volatileä¿è¯æ•°ç»„å¼•ç”¨çš„åŸå­æ›¿æ¢

### 4.3 ä½¿ç”¨ç¤ºä¾‹

```java
/**
 * CopyOnWriteArrayListä½¿ç”¨ç¤ºä¾‹
 * CopyOnWriteArrayList Usage Example
 */
public class CopyOnWriteArrayListDemo {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        
        // æ·»åŠ å…ƒç´ ï¼ˆå†™æ“ä½œï¼šå¤åˆ¶æ•°ç»„ï¼‰
        list.add("item1");
        list.add("item2");
        
        // è¯»å–å…ƒç´ ï¼ˆè¯»æ“ä½œï¼šæ— é”ï¼Œé«˜æ€§èƒ½ï¼‰
        String item = list.get(0);
        
        // éå†ï¼ˆå¼±ä¸€è‡´æ€§ï¼šå¯èƒ½è¯»åˆ°æ—§æ•°æ®ï¼‰
        for (String s : list) {
            System.out.println(s);
        }
    }
}
```

### 4.4 æ³¨æ„äº‹é¡¹

âš ï¸ **å¼±ä¸€è‡´æ€§ï¼š** è¯»æ“ä½œå¯èƒ½è¯»åˆ°æ—§æ•°æ®

```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A");

// çº¿ç¨‹1ï¼šéå†
new Thread(() -> {
    for (String s : list) {
        System.out.println(s); // å¯èƒ½åªæ‰“å°"A"
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}).start();

// çº¿ç¨‹2ï¼šæ·»åŠ å…ƒç´ 
new Thread(() -> {
    try {
        Thread.sleep(50);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    list.add("B"); // åˆ›å»ºæ–°æ•°ç»„ï¼Œä½†çº¿ç¨‹1ä»åœ¨ä½¿ç”¨æ—§æ•°ç»„
}).start();
```

---

## 5. ConcurrentLinkedQueue (ConcurrentLinkedQueue)

### 5.1 æ ¸å¿ƒç‰¹ç‚¹

**ConcurrentLinkedQueueï¼ˆå¹¶å‘é“¾è¡¨é˜Ÿåˆ—ï¼‰**ï¼šåŸºäºCASå®ç°çš„æ— é”é˜Ÿåˆ—ã€‚

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **çº¿ç¨‹å®‰å…¨** | CASæ— é”å®ç° |
| **æ€§èƒ½** | é«˜ï¼ˆæ— é”ï¼‰ |
| **æœ‰ç•Œæ€§** | æ— ç•Œé˜Ÿåˆ— |
| **é€‚ç”¨åœºæ™¯** | é«˜å¹¶å‘é˜Ÿåˆ—æ“ä½œ |

### 5.2 å®ç°åŸç†

```java
/**
 * ConcurrentLinkedQueueæ ¸å¿ƒå®ç°
 * Core Implementation
 */
public class ConcurrentLinkedQueue<E> {
    // å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹
    private transient volatile Node<E> head;
    private transient volatile Node<E> tail;
    
    // å…¥é˜Ÿï¼šCASæ“ä½œ
    public boolean offer(E e) {
        Node<E> newNode = new Node<E>(e);
        for (Node<E> t = tail, p = t;;) {
            Node<E> q = p.next;
            if (q == null) {
                // CASè®¾ç½®next
                if (p.casNext(null, newNode)) {
                    // æ›´æ–°tail
                    if (p != t)
                        casTail(t, newNode);
                    return true;
                }
            }
            // ... å…¶ä»–é€»è¾‘
        }
    }
    
    // å‡ºé˜Ÿï¼šCASæ“ä½œ
    public E poll() {
        // ... CASæ“ä½œé€»è¾‘
    }
}
```

**å…³é”®ç‚¹ï¼š** ä½¿ç”¨CASä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œæ— é”é«˜æ€§èƒ½ã€‚

### 5.3 ä½¿ç”¨ç¤ºä¾‹

```java
/**
 * ConcurrentLinkedQueueä½¿ç”¨ç¤ºä¾‹
 * ConcurrentLinkedQueue Usage Example
 */
public class ConcurrentLinkedQueueDemo {
    public static void main(String[] args) {
        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
        
        // å…¥é˜Ÿ
        queue.offer("item1");
        queue.offer("item2");
        
        // å‡ºé˜Ÿ
        String item = queue.poll();
        
        // æ£€æŸ¥
        String peek = queue.peek();
    }
}
```

---

## 6. å¹¶å‘é›†åˆå¯¹æ¯” (Concurrent Collections Comparison)

### 6.1 å¯¹æ¯”è¡¨

| é›†åˆç±» | çº¿ç¨‹å®‰å…¨æœºåˆ¶ | æ€§èƒ½ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|--------|------------|---------|---------|
| **ConcurrentHashMap** | CAS + synchronized | é«˜å¹¶å‘æ€§èƒ½å¥½ | é«˜å¹¶å‘Mapåœºæ™¯ |
| **BlockingQueue** | ReentrantLock + Condition | é˜»å¡æœºåˆ¶ | ç”Ÿäº§è€…-æ¶ˆè´¹è€… |
| **CopyOnWriteArrayList** | å†™æ—¶å¤åˆ¶ | è¯»å¿«å†™æ…¢ | è¯»å¤šå†™å°‘ |
| **ConcurrentLinkedQueue** | CAS | æ— é”é˜Ÿåˆ— | é«˜å¹¶å‘é˜Ÿåˆ— |

### 6.2 é€‰æ‹©å»ºè®®

**ä½¿ç”¨ConcurrentHashMapï¼š**
- éœ€è¦çº¿ç¨‹å®‰å…¨çš„Map
- é«˜å¹¶å‘è¯»å†™åœºæ™¯

**ä½¿ç”¨BlockingQueueï¼š**
- ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼
- éœ€è¦é˜»å¡æ“ä½œ

**ä½¿ç”¨CopyOnWriteArrayListï¼š**
- è¯»å¤šå†™å°‘åœºæ™¯
- å¯ä»¥å®¹å¿å¼±ä¸€è‡´æ€§

**ä½¿ç”¨ConcurrentLinkedQueueï¼š**
- é«˜å¹¶å‘é˜Ÿåˆ—æ“ä½œ
- ä¸éœ€è¦é˜»å¡æ“ä½œ

---

## 7. æœ€ä½³å®è·µ (Best Practices)

### 7.1 é€‰æ‹©åˆé€‚çš„å¹¶å‘é›†åˆ

```java
// âœ… é«˜å¹¶å‘Mapï¼šä½¿ç”¨ConcurrentHashMap
ConcurrentHashMap<String, Object> cache = new ConcurrentHashMap<>();

// âœ… ç”Ÿäº§è€…-æ¶ˆè´¹è€…ï¼šä½¿ç”¨BlockingQueue
BlockingQueue<Task> taskQueue = new LinkedBlockingQueue<>(1000);

// âœ… è¯»å¤šå†™å°‘ï¼šä½¿ç”¨CopyOnWriteArrayList
CopyOnWriteArrayList<String> configList = new CopyOnWriteArrayList<>();

// âœ… é«˜å¹¶å‘é˜Ÿåˆ—ï¼šä½¿ç”¨ConcurrentLinkedQueue
ConcurrentLinkedQueue<String> messageQueue = new ConcurrentLinkedQueue<>();
```

### 7.2 æ³¨æ„CopyOnWriteArrayListçš„å†…å­˜æ¶ˆè€—

```java
// âš ï¸ æ³¨æ„ï¼šCopyOnWriteArrayListå†™æ“ä½œä¼šå¤åˆ¶æ•´ä¸ªæ•°ç»„
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();

// å¦‚æœlistå¾ˆå¤§ï¼Œé¢‘ç¹å†™æ“ä½œä¼šå¯¼è‡´å†…å­˜æ¶ˆè€—å¤§
for (int i = 0; i < 10000; i++) {
    list.add("item" + i); // æ¯æ¬¡addéƒ½å¤åˆ¶æ•´ä¸ªæ•°ç»„ï¼
}

// âœ… å»ºè®®ï¼šæ‰¹é‡æ“ä½œ
List<String> batch = new ArrayList<>();
// ... æ·»åŠ å…ƒç´ åˆ°batch
list.addAll(batch); // åªå¤åˆ¶ä¸€æ¬¡
```

### 7.3 ä½¿ç”¨ConcurrentHashMapçš„åŸå­æ“ä½œ

```java
ConcurrentHashMap<String, AtomicLong> map = new ConcurrentHashMap<>();

// âœ… ä½¿ç”¨computeIfAbsenté¿å…é‡å¤è®¡ç®—
map.computeIfAbsent("key", k -> {
    // åªåœ¨keyä¸å­˜åœ¨æ—¶æ‰§è¡Œ
    return new AtomicLong(expensiveComputation());
});

// âœ… ä½¿ç”¨computeIfPresentåŸå­æ›´æ–°
map.computeIfPresent("key", (k, v) -> {
    return new AtomicLong(v.get() + 1);
});
```

---

## 8. é¢è¯•é«˜é¢‘é—®é¢˜ (Interview Questions)

### Q1: ConcurrentHashMapçš„å®ç°åŸç†ï¼Ÿ

**ç­”æ¡ˆï¼š** JDK 1.8ä½¿ç”¨CAS + synchronizedå®ç°ï¼Œæ¡¶ä¸ºç©ºæ—¶CASæ’å…¥ï¼Œæ¡¶ä¸ä¸ºç©ºæ—¶é”ä½é“¾è¡¨å¤´èŠ‚ç‚¹ã€‚getæ“ä½œæ— é”ã€‚

### Q2: ConcurrentHashMapå’ŒHashMapçš„åŒºåˆ«ï¼Ÿ

**ç­”æ¡ˆï¼š** ConcurrentHashMapçº¿ç¨‹å®‰å…¨ï¼Œä½¿ç”¨CAS + synchronizedï¼›HashMapéçº¿ç¨‹å®‰å…¨ï¼Œæ€§èƒ½æ›´é«˜ã€‚

### Q3: BlockingQueueçš„å®ç°åŸç†ï¼Ÿ

**ç­”æ¡ˆï¼š** åŸºäºReentrantLockå’ŒConditionå®ç°é˜»å¡ï¼Œputæ“ä½œåœ¨é˜Ÿåˆ—æ»¡æ—¶é˜»å¡ï¼Œtakeæ“ä½œåœ¨é˜Ÿåˆ—ç©ºæ—¶é˜»å¡ã€‚

### Q4: CopyOnWriteArrayListçš„ä¼˜ç¼ºç‚¹ï¼Ÿ

**ç­”æ¡ˆï¼š**
- ä¼˜ç‚¹ï¼šè¯»æ“ä½œæ— é”ï¼Œæ€§èƒ½é«˜
- ç¼ºç‚¹ï¼šå†™æ“ä½œéœ€è¦å¤åˆ¶æ•´ä¸ªæ•°ç»„ï¼Œå†…å­˜æ¶ˆè€—å¤§ï¼Œå¼±ä¸€è‡´æ€§

### Q5: å¦‚ä½•é€‰æ‹©åˆé€‚çš„å¹¶å‘é›†åˆï¼Ÿ

**ç­”æ¡ˆï¼š** æ ¹æ®ä½¿ç”¨åœºæ™¯é€‰æ‹©ï¼šConcurrentHashMapç”¨äºMapï¼ŒBlockingQueueç”¨äºç”Ÿäº§è€…-æ¶ˆè´¹è€…ï¼ŒCopyOnWriteArrayListç”¨äºè¯»å¤šå†™å°‘ã€‚

---

## ğŸ“– æ‰©å±•é˜…è¯»

- [ConcurrentHashMap API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html)
- [BlockingQueue API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html)

---

**è¿”å›ï¼š** [07-Javaå¹¶å‘ç¼–ç¨‹](./07-Javaå¹¶å‘ç¼–ç¨‹.md)  
**ä¸Šä¸€ç« ï¼š** [07-05 - çº¿ç¨‹æ± ](./07-05-çº¿ç¨‹æ± .md)

