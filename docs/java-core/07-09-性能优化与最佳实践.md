# æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ (Performance Optimization & Best Practices)

> æŒæ¡å¹¶å‘æ€§èƒ½è°ƒä¼˜æŠ€å·§ï¼Œäº†è§£å¸¸è§å¹¶å‘é—®é¢˜ï¼ˆæ­»é”ã€æ´»é”ã€é¥¥é¥¿ï¼‰åŠè§£å†³æ–¹æ¡ˆï¼Œå­¦ä¹ ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ

## ç›®å½•
- [1. æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#1-æ€§èƒ½ä¼˜åŒ–æŠ€å·§)
- [2. å¸¸è§å¹¶å‘é—®é¢˜](#2-å¸¸è§å¹¶å‘é—®é¢˜)
- [3. æ­»é”é—®é¢˜](#3-æ­»é”é—®é¢˜)
- [4. æ´»é”å’Œé¥¥é¥¿](#4-æ´»é”å’Œé¥¥é¥¿)
- [5. çº¿ç¨‹å®‰å…¨è®¾è®¡åŸåˆ™](#5-çº¿ç¨‹å®‰å…¨è®¾è®¡åŸåˆ™)
- [6. ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ](#6-ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ)
- [7. æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜](#7-æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜)
- [8. é¢è¯•é«˜é¢‘é—®é¢˜](#8-é¢è¯•é«˜é¢‘é—®é¢˜)

---

## 1. æ€§èƒ½ä¼˜åŒ–æŠ€å·§ (Performance Optimization Tips)

### 1.1 å‡å°‘é”çš„ç²’åº¦

```java
/**
 * é”ç²’åº¦ä¼˜åŒ–
 * Lock Granularity Optimization
 */
public class LockGranularity {
    
    // âŒ ä¸æ¨èï¼šé”èŒƒå›´å¤ªå¤§
    public synchronized void process() {
        doSomething1(); // ä¸éœ€è¦åŒæ­¥
        synchronized (this) {
            count++; // éœ€è¦åŒæ­¥
        }
        doSomething2(); // ä¸éœ€è¦åŒæ­¥
    }
    
    // âœ… æ¨èï¼šåªé”å¿…è¦çš„ä»£ç 
    public void process() {
        doSomething1();
        synchronized (this) {
            count++; // åªé”å¿…è¦çš„ä»£ç 
        }
        doSomething2();
    }
}
```

### 1.2 ä½¿ç”¨æ— é”æ•°æ®ç»“æ„

```java
/**
 * æ— é”æ•°æ®ç»“æ„ä¼˜åŒ–
 * Lock-Free Data Structure Optimization
 */
public class LockFreeOptimization {
    
    // âŒ ä½¿ç”¨synchronized
    private int count = 0;
    public synchronized void increment() {
        count++;
    }
    
    // âœ… ä½¿ç”¨AtomicIntegerï¼ˆæ— é”ï¼‰
    private AtomicInteger count = new AtomicInteger(0);
    public void increment() {
        count.incrementAndGet();
    }
    
    // âœ… é«˜å¹¶å‘åœºæ™¯ï¼šä½¿ç”¨LongAdder
    private LongAdder highConcurrencyCount = new LongAdder();
    public void increment() {
        highConcurrencyCount.increment();
    }
}
```

### 1.3 è¯»å†™åˆ†ç¦»

```java
/**
 * è¯»å†™åˆ†ç¦»ä¼˜åŒ–
 * Read-Write Separation Optimization
 */
public class ReadWriteSeparation {
    
    // âŒ ä½¿ç”¨synchronizedï¼ˆè¯»å†™éƒ½äº’æ–¥ï¼‰
    private Map<String, String> cache = new HashMap<>();
    public synchronized String get(String key) {
        return cache.get(key);
    }
    public synchronized void put(String key, String value) {
        cache.put(key, value);
    }
    
    // âœ… ä½¿ç”¨ReadWriteLockï¼ˆè¯»å¯ä»¥å¹¶å‘ï¼‰
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    private Map<String, String> cache2 = new HashMap<>();
    
    public String get(String key) {
        lock.readLock().lock();
        try {
            return cache2.get(key);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void put(String key, String value) {
        lock.writeLock().lock();
        try {
            cache2.put(key, value);
        } finally {
            lock.writeLock().unlock();
        }
    }
}
```

### 1.4 ä½¿ç”¨çº¿ç¨‹æ± 

```java
/**
 * çº¿ç¨‹æ± ä¼˜åŒ–
 * Thread Pool Optimization
 */
public class ThreadPoolOptimization {
    
    // âŒ ç›´æ¥åˆ›å»ºçº¿ç¨‹ï¼ˆå¼€é”€å¤§ï¼‰
    for (int i = 0; i < 1000; i++) {
        new Thread(() -> {
            doTask();
        }).start();
    }
    
    // âœ… ä½¿ç”¨çº¿ç¨‹æ± ï¼ˆèµ„æºå¤ç”¨ï¼‰
    ExecutorService executor = Executors.newFixedThreadPool(10);
    for (int i = 0; i < 1000; i++) {
        executor.submit(() -> {
            doTask();
        });
    }
}
```

### 1.5 æ‰¹é‡å¤„ç†

```java
/**
 * æ‰¹é‡å¤„ç†ä¼˜åŒ–
 * Batch Processing Optimization
 */
public class BatchProcessing {
    
    // âŒ é€ä¸ªå¤„ç†ï¼ˆé”ç«äº‰é¢‘ç¹ï¼‰
    public void processOneByOne(List<Item> items) {
        for (Item item : items) {
            synchronized (this) {
                process(item);
            }
        }
    }
    
    // âœ… æ‰¹é‡å¤„ç†ï¼ˆå‡å°‘é”ç«äº‰ï¼‰
    public void processBatch(List<Item> items) {
        List<Item> batch = new ArrayList<>();
        synchronized (this) {
            batch.addAll(items);
        }
        processBatch(batch); // æ‰¹é‡å¤„ç†
    }
}
```

---

## 2. å¸¸è§å¹¶å‘é—®é¢˜ (Common Concurrency Problems)

### 2.1 é—®é¢˜åˆ†ç±»

| é—®é¢˜ç±»å‹ | è¯´æ˜ | ä¸¥é‡ç¨‹åº¦ |
|---------|------|---------|
| **æ­»é”ï¼ˆDeadlockï¼‰** | å¤šä¸ªçº¿ç¨‹ç›¸äº’ç­‰å¾…ï¼Œæ— æ³•ç»§ç»­ | â­â­â­â­â­ |
| **æ´»é”ï¼ˆLivelockï¼‰** | çº¿ç¨‹ä¸æ–­é‡è¯•ï¼Œä½†æ— æ³•å–å¾—è¿›å±• | â­â­â­â­ |
| **é¥¥é¥¿ï¼ˆStarvationï¼‰** | çº¿ç¨‹é•¿æ—¶é—´æ— æ³•è·å¾—èµ„æº | â­â­â­ |
| **ç«æ€æ¡ä»¶ï¼ˆRace Conditionï¼‰** | ç»“æœä¾èµ–äºæ‰§è¡Œé¡ºåº | â­â­â­â­ |
| **æ•°æ®ç«äº‰ï¼ˆData Raceï¼‰** | å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«æ•°æ® | â­â­â­â­ |

### 2.2 é—®é¢˜ç¤ºä¾‹

```java
/**
 * å¸¸è§å¹¶å‘é—®é¢˜ç¤ºä¾‹
 * Common Concurrency Problems Examples
 */
public class ConcurrencyProblems {
    
    // 1. æ­»é”
    private Object lock1 = new Object();
    private Object lock2 = new Object();
    
    public void deadlock() {
        // çº¿ç¨‹1ï¼šå…ˆè·å–lock1ï¼Œå†è·å–lock2
        new Thread(() -> {
            synchronized (lock1) {
                synchronized (lock2) {
                    // ...
                }
            }
        }).start();
        
        // çº¿ç¨‹2ï¼šå…ˆè·å–lock2ï¼Œå†è·å–lock1ï¼ˆç›¸åé¡ºåºï¼Œå¯èƒ½æ­»é”ï¼‰
        new Thread(() -> {
            synchronized (lock2) {
                synchronized (lock1) {
                    // ...
                }
            }
        }).start();
    }
    
    // 2. ç«æ€æ¡ä»¶
    private int count = 0;
    
    public void raceCondition() {
        // å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œï¼Œç»“æœä¸ç¡®å®š
        new Thread(() -> count++).start();
        new Thread(() -> count++).start();
        // countçš„å€¼ä¸ç¡®å®š
    }
}
```

---

## 3. æ­»é”é—®é¢˜ (Deadlock Problem)

### 3.1 æ­»é”çš„æ¡ä»¶

æ­»é”å‘ç”Ÿçš„å››ä¸ªå¿…è¦æ¡ä»¶ï¼ˆ**ç¼ºä¸€ä¸å¯**ï¼‰ï¼š

1. **äº’æ–¥æ¡ä»¶** - èµ„æºä¸èƒ½è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶ä½¿ç”¨
2. **è¯·æ±‚ä¸ä¿æŒ** - çº¿ç¨‹æŒæœ‰èµ„æºçš„åŒæ—¶è¯·æ±‚å…¶ä»–èµ„æº
3. **ä¸å¯å‰¥å¤º** - èµ„æºä¸èƒ½è¢«å¼ºåˆ¶é‡Šæ”¾
4. **å¾ªç¯ç­‰å¾…** - å¤šä¸ªçº¿ç¨‹å½¢æˆå¾ªç¯ç­‰å¾…é“¾

### 3.2 æ­»é”ç¤ºä¾‹

```java
/**
 * æ­»é”ç¤ºä¾‹
 * Deadlock Example
 */
public class DeadlockExample {
    private Object lock1 = new Object();
    private Object lock2 = new Object();
    
    public void method1() {
        synchronized (lock1) {
            System.out.println("çº¿ç¨‹1æŒæœ‰lock1");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lock2) {
                System.out.println("çº¿ç¨‹1æŒæœ‰lock2");
            }
        }
    }
    
    public void method2() {
        synchronized (lock2) {
            System.out.println("çº¿ç¨‹2æŒæœ‰lock2");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lock1) {
                System.out.println("çº¿ç¨‹2æŒæœ‰lock1");
            }
        }
    }
    
    public static void main(String[] args) {
        DeadlockExample demo = new DeadlockExample();
        new Thread(demo::method1).start();
        new Thread(demo::method2).start();
        // å¯èƒ½å‘ç”Ÿæ­»é”
    }
}
```

### 3.3 æ­»é”æ£€æµ‹

```java
/**
 * æ­»é”æ£€æµ‹å·¥å…·
 * Deadlock Detection Tools
 */
public class DeadlockDetection {
    public void detectDeadlock() {
        // ä½¿ç”¨jstackæ£€æµ‹æ­»é”
        // jstack <pid> | grep -i deadlock
        
        // ä½¿ç”¨ThreadMXBeanæ£€æµ‹æ­»é”
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        long[] deadlockedThreads = threadBean.findDeadlockedThreads();
        if (deadlockedThreads != null) {
            ThreadInfo[] threadInfos = threadBean.getThreadInfo(deadlockedThreads);
            for (ThreadInfo threadInfo : threadInfos) {
                System.out.println("æ­»é”çº¿ç¨‹: " + threadInfo.getThreadName());
            }
        }
    }
}
```

### 3.4 æ­»é”é¢„é˜²å’Œè§£å†³

```java
/**
 * æ­»é”é¢„é˜²å’Œè§£å†³
 * Deadlock Prevention and Solution
 */
public class DeadlockPrevention {
    
    // æ–¹æ³•1ï¼šç»Ÿä¸€é”é¡ºåº
    public void uniformLockOrder() {
        // æ‰€æœ‰çº¿ç¨‹æŒ‰ç›¸åŒé¡ºåºè·å–é”
        synchronized (lock1) {
            synchronized (lock2) {
                // ...
            }
        }
    }
    
    // æ–¹æ³•2ï¼šä½¿ç”¨è¶…æ—¶é”
    public void timeoutLock() {
        try {
            if (lock1.tryLock(5, TimeUnit.SECONDS)) {
                try {
                    if (lock2.tryLock(5, TimeUnit.SECONDS)) {
                        try {
                            // ...
                        } finally {
                            lock2.unlock();
                        }
                    }
                } finally {
                    lock1.unlock();
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    // æ–¹æ³•3ï¼šé¿å…åµŒå¥—é”
    public void avoidNestedLocks() {
        // å°½é‡å‡å°‘é”çš„åµŒå¥—
        // ä½¿ç”¨æ›´ç»†ç²’åº¦çš„é”
    }
    
    // æ–¹æ³•4ï¼šä½¿ç”¨æ— é”æ•°æ®ç»“æ„
    public void useLockFreeStructures() {
        // ä½¿ç”¨ConcurrentHashMapã€AtomicIntegerç­‰
        // é¿å…ä½¿ç”¨synchronized
    }
}
```

---

## 4. æ´»é”å’Œé¥¥é¥¿ (Livelock and Starvation)

### 4.1 æ´»é”ï¼ˆLivelockï¼‰

**æ´»é”**ï¼šçº¿ç¨‹ä¸æ–­é‡è¯•ï¼Œä½†æ— æ³•å–å¾—è¿›å±•ã€‚

```java
/**
 * æ´»é”ç¤ºä¾‹
 * Livelock Example
 */
public class LivelockExample {
    private boolean flag = true;
    
    public void livelock() {
        // çº¿ç¨‹1ï¼šä¸æ–­é‡è¯•
        new Thread(() -> {
            while (flag) {
                if (tryAcquire()) {
                    flag = false;
                } else {
                    Thread.yield(); // è®©å‡ºCPUï¼Œä½†ç«‹å³é‡è¯•
                }
            }
        }).start();
        
        // çº¿ç¨‹2ï¼šåŒæ ·ä¸æ–­é‡è¯•
        new Thread(() -> {
            while (flag) {
                if (tryAcquire()) {
                    flag = false;
                } else {
                    Thread.yield(); // è®©å‡ºCPUï¼Œä½†ç«‹å³é‡è¯•
                }
            }
        }).start();
        // ä¸¤ä¸ªçº¿ç¨‹ä¸æ–­é‡è¯•ï¼Œä½†éƒ½æ— æ³•æˆåŠŸ
    }
}
```

**è§£å†³æ–¹æ¡ˆï¼š**
- å¼•å…¥éšæœºé€€é¿ï¼ˆRandom Backoffï¼‰
- ä½¿ç”¨è¶…æ—¶æœºåˆ¶
- é‡æ–°è®¾è®¡ç®—æ³•

### 4.2 é¥¥é¥¿ï¼ˆStarvationï¼‰

**é¥¥é¥¿**ï¼šçº¿ç¨‹é•¿æ—¶é—´æ— æ³•è·å¾—èµ„æºã€‚

```java
/**
 * é¥¥é¥¿ç¤ºä¾‹
 * Starvation Example
 */
public class StarvationExample {
    private ReentrantLock lock = new ReentrantLock(); // éå…¬å¹³é”
    
    public void starvation() {
        // é«˜ä¼˜å…ˆçº§çº¿ç¨‹æ€»æ˜¯å…ˆè·å¾—é”
        Thread highPriorityThread = new Thread(() -> {
            while (true) {
                lock.lock();
                try {
                    // é•¿æ—¶é—´æŒæœ‰é”
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        });
        highPriorityThread.setPriority(Thread.MAX_PRIORITY);
        highPriorityThread.start();
        
        // ä½ä¼˜å…ˆçº§çº¿ç¨‹å¯èƒ½æ°¸è¿œæ— æ³•è·å¾—é”
        Thread lowPriorityThread = new Thread(() -> {
            lock.lock(); // å¯èƒ½æ°¸è¿œç­‰å¾…
            try {
                // ...
            } finally {
                lock.unlock();
            }
        });
        lowPriorityThread.setPriority(Thread.MIN_PRIORITY);
        lowPriorityThread.start();
    }
}
```

**è§£å†³æ–¹æ¡ˆï¼š**
- ä½¿ç”¨å…¬å¹³é”
- åˆç†è®¾ç½®çº¿ç¨‹ä¼˜å…ˆçº§
- é¿å…é•¿æ—¶é—´æŒæœ‰é”

---

## 5. çº¿ç¨‹å®‰å…¨è®¾è®¡åŸåˆ™ (Thread Safety Design Principles)

### 5.1 åŸåˆ™1ï¼šä¸å¯å˜å¯¹è±¡

```java
/**
 * ä¸å¯å˜å¯¹è±¡ï¼šå¤©ç„¶çº¿ç¨‹å®‰å…¨
 * Immutable Objects: Naturally Thread-Safe
 */
public final class ImmutableConfig {
    private final String key;
    private final String value;
    
    public ImmutableConfig(String key, String value) {
        this.key = key;
        this.value = value;
    }
    
    public String getKey() {
        return key;
    }
    
    public String getValue() {
        return value;
    }
    // æ²¡æœ‰setteræ–¹æ³•ï¼Œå¯¹è±¡ä¸å¯å˜
}
```

### 5.2 åŸåˆ™2ï¼šçº¿ç¨‹å°é—­

```java
/**
 * çº¿ç¨‹å°é—­ï¼šæ¯ä¸ªçº¿ç¨‹ä½¿ç”¨ç‹¬ç«‹çš„å¯¹è±¡
 * Thread Confinement: Each Thread Uses Independent Objects
 */
public class ThreadConfinement {
    // ä½¿ç”¨ThreadLocalå®ç°çº¿ç¨‹å°é—­
    private ThreadLocal<String> threadLocal = new ThreadLocal<>();
    
    public void setValue(String value) {
        threadLocal.set(value); // æ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹çš„å€¼
    }
}
```

### 5.3 åŸåˆ™3ï¼šä½¿ç”¨çº¿ç¨‹å®‰å…¨ç±»

```java
/**
 * ä½¿ç”¨çº¿ç¨‹å®‰å…¨ç±»
 * Use Thread-Safe Classes
 */
public class ThreadSafeClasses {
    // âœ… ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„é›†åˆ
    private ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
    private CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
    
    // âœ… ä½¿ç”¨åŸå­ç±»
    private AtomicInteger counter = new AtomicInteger(0);
    
    // âŒ é¿å…ä½¿ç”¨éçº¿ç¨‹å®‰å…¨çš„ç±»
    // private HashMap<String, String> unsafeMap = new HashMap<>();
}
```

### 5.4 åŸåˆ™4ï¼šåŒæ­¥æœ€å°åŒ–

```java
/**
 * åŒæ­¥æœ€å°åŒ–ï¼šåªåŒæ­¥å¿…è¦çš„ä»£ç 
 * Minimize Synchronization: Only Synchronize Necessary Code
 */
public class MinimizeSynchronization {
    // âœ… åªåŒæ­¥å¿…è¦çš„ä»£ç å—
    public void process() {
        doSomething1(); // ä¸éœ€è¦åŒæ­¥
        synchronized (this) {
            criticalSection(); // åªåŒæ­¥å…³é”®éƒ¨åˆ†
        }
        doSomething2(); // ä¸éœ€è¦åŒæ­¥
    }
}
```

---

## 6. ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ (Production Best Practices)

### 6.1 çº¿ç¨‹æ± é…ç½®

```java
/**
 * ç”Ÿäº§ç¯å¢ƒçº¿ç¨‹æ± é…ç½®
 * Production Thread Pool Configuration
 */
public class ProductionThreadPool {
    
    // âœ… æ¨èï¼šè‡ªå®šä¹‰ThreadPoolExecutor
    public ThreadPoolExecutor createThreadPool() {
        int corePoolSize = Runtime.getRuntime().availableProcessors();
        int maximumPoolSize = corePoolSize * 2;
        
        return new ThreadPoolExecutor(
            corePoolSize,
            maximumPoolSize,
            60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(1000), // æœ‰ç•Œé˜Ÿåˆ—
            new ThreadFactoryBuilder()
                .setNameFormat("task-%d")
                .setUncaughtExceptionHandler((t, e) -> {
                    logger.error("çº¿ç¨‹{}æœªæ•è·å¼‚å¸¸", t.getName(), e);
                })
                .build(),
            new ThreadPoolExecutor.CallerRunsPolicy() // æ‹’ç»ç­–ç•¥
        );
    }
    
    // âŒ ä¸æ¨èï¼šä½¿ç”¨Executorså·¥å…·ç±»ï¼ˆæ— ç•Œé˜Ÿåˆ—å¯èƒ½å¯¼è‡´OOMï¼‰
    // ExecutorService executor = Executors.newFixedThreadPool(10);
}
```

### 6.2 å¼‚å¸¸å¤„ç†

```java
/**
 * ç”Ÿäº§ç¯å¢ƒå¼‚å¸¸å¤„ç†
 * Production Exception Handling
 */
public class ProductionExceptionHandling {
    
    // âœ… è®¾ç½®æœªæ•è·å¼‚å¸¸å¤„ç†å™¨
    Thread.setDefaultUncaughtExceptionHandler((t, e) -> {
        logger.error("çº¿ç¨‹{}æœªæ•è·å¼‚å¸¸", t.getName(), e);
        // å‘é€å‘Šè­¦
        alertService.sendAlert("çº¿ç¨‹å¼‚å¸¸", e);
    });
    
    // âœ… çº¿ç¨‹æ± ä»»åŠ¡å¼‚å¸¸å¤„ç†
    executorService.submit(() -> {
        try {
            riskyOperation();
        } catch (Exception e) {
            logger.error("ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸", e);
            // ä¸è¦åæ‰å¼‚å¸¸
        }
    });
}
```

### 6.3 èµ„æºæ¸…ç†

```java
/**
 * ç”Ÿäº§ç¯å¢ƒèµ„æºæ¸…ç†
 * Production Resource Cleanup
 */
public class ProductionResourceCleanup {
    
    // âœ… æ­£ç¡®å…³é—­çº¿ç¨‹æ± 
    public void shutdownThreadPool(ExecutorService executor) {
        executor.shutdown(); // åœæ­¢æ¥æ”¶æ–°ä»»åŠ¡
        try {
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                executor.shutdownNow(); // å¼ºåˆ¶å…³é—­
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    logger.error("çº¿ç¨‹æ± æœªèƒ½æ­£å¸¸å…³é—­");
                }
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
    
    // âœ… ThreadLocalæ¸…ç†
    public void cleanupThreadLocal() {
        try {
            // ä½¿ç”¨ThreadLocal
            threadLocal.set(value);
        } finally {
            threadLocal.remove(); // å¿…é¡»æ¸…ç†
        }
    }
}
```

### 6.4 ç›‘æ§å’Œæ—¥å¿—

```java
/**
 * ç”Ÿäº§ç¯å¢ƒç›‘æ§å’Œæ—¥å¿—
 * Production Monitoring and Logging
 */
public class ProductionMonitoring {
    
    // çº¿ç¨‹æ± ç›‘æ§
    @Scheduled(fixedRate = 60000)
    public void monitorThreadPool() {
        ThreadPoolExecutor executor = (ThreadPoolExecutor) executorService;
        
        int queueSize = executor.getQueue().size();
        int activeCount = executor.getActiveCount();
        long completedTaskCount = executor.getCompletedTaskCount();
        
        // å‘Šè­¦ï¼šé˜Ÿåˆ—ç§¯å‹
        if (queueSize > 1000) {
            logger.warn("çº¿ç¨‹æ± é˜Ÿåˆ—ç§¯å‹: {}", queueSize);
            alertService.sendAlert("çº¿ç¨‹æ± é˜Ÿåˆ—ç§¯å‹", queueSize);
        }
        
        // å‘Šè­¦ï¼šçº¿ç¨‹æ± æ»¡è½½
        if (activeCount == executor.getMaximumPoolSize()) {
            logger.warn("çº¿ç¨‹æ± æ»¡è½½");
            alertService.sendAlert("çº¿ç¨‹æ± æ»¡è½½");
        }
    }
    
    // æ­»é”æ£€æµ‹
    @Scheduled(fixedRate = 300000) // 5åˆ†é’Ÿæ£€æµ‹ä¸€æ¬¡
    public void detectDeadlock() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        long[] deadlockedThreads = threadBean.findDeadlockedThreads();
        if (deadlockedThreads != null) {
            logger.error("æ£€æµ‹åˆ°æ­»é”");
            alertService.sendAlert("æ£€æµ‹åˆ°æ­»é”", deadlockedThreads);
        }
    }
}
```

---

## 7. æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜ (Performance Monitoring and Tuning)

### 7.1 æ€§èƒ½æŒ‡æ ‡

```java
/**
 * å¹¶å‘æ€§èƒ½æŒ‡æ ‡
 * Concurrency Performance Metrics
 */
public class PerformanceMetrics {
    
    // çº¿ç¨‹æ± æŒ‡æ ‡
    public void threadPoolMetrics(ThreadPoolExecutor executor) {
        // æ ¸å¿ƒçº¿ç¨‹æ•°
        int corePoolSize = executor.getCorePoolSize();
        
        // æœ€å¤§çº¿ç¨‹æ•°
        int maximumPoolSize = executor.getMaximumPoolSize();
        
        // å½“å‰çº¿ç¨‹æ•°
        int poolSize = executor.getPoolSize();
        
        // æ´»è·ƒçº¿ç¨‹æ•°
        int activeCount = executor.getActiveCount();
        
        // å·²å®Œæˆä»»åŠ¡æ•°
        long completedTaskCount = executor.getCompletedTaskCount();
        
        // æ€»ä»»åŠ¡æ•°
        long taskCount = executor.getTaskCount();
        
        // é˜Ÿåˆ—å¤§å°
        int queueSize = executor.getQueue().size();
    }
    
    // JVMçº¿ç¨‹æŒ‡æ ‡
    public void jvmThreadMetrics() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        
        // çº¿ç¨‹æ€»æ•°
        int threadCount = threadBean.getThreadCount();
        
        // å³°å€¼çº¿ç¨‹æ•°
        int peakThreadCount = threadBean.getPeakThreadCount();
        
        // æ­»é”çº¿ç¨‹
        long[] deadlockedThreads = threadBean.findDeadlockedThreads();
    }
}
```

### 7.2 æ€§èƒ½è°ƒä¼˜å»ºè®®

1. **çº¿ç¨‹æ± å¤§å°è°ƒä¼˜**
   - CPUå¯†é›†å‹ï¼šçº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•°
   - IOå¯†é›†å‹ï¼šçº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° * 2

2. **å‡å°‘é”ç«äº‰**
   - ä½¿ç”¨æ— é”æ•°æ®ç»“æ„
   - å‡å°‘é”çš„ç²’åº¦
   - è¯»å†™åˆ†ç¦»

3. **æ‰¹é‡å¤„ç†**
   - å‡å°‘é”çš„è·å–æ¬¡æ•°
   - æé«˜ååé‡

4. **ç›‘æ§å’Œå‘Šè­¦**
   - ç›‘æ§çº¿ç¨‹æ± çŠ¶æ€
   - æ£€æµ‹æ­»é”
   - è®¾ç½®åˆç†çš„å‘Šè­¦é˜ˆå€¼

---

## 8. é¢è¯•é«˜é¢‘é—®é¢˜ (Interview Questions)

### Q1: å¦‚ä½•é¿å…æ­»é”ï¼Ÿ

**ç­”æ¡ˆï¼š**
1. ç»Ÿä¸€é”é¡ºåº
2. ä½¿ç”¨è¶…æ—¶é”
3. é¿å…åµŒå¥—é”
4. ä½¿ç”¨æ— é”æ•°æ®ç»“æ„

### Q2: æ­»é”ã€æ´»é”ã€é¥¥é¥¿çš„åŒºåˆ«ï¼Ÿ

**ç­”æ¡ˆï¼š**
- **æ­»é”**ï¼šçº¿ç¨‹ç›¸äº’ç­‰å¾…ï¼Œæ— æ³•ç»§ç»­
- **æ´»é”**ï¼šçº¿ç¨‹ä¸æ–­é‡è¯•ï¼Œä½†æ— æ³•å–å¾—è¿›å±•
- **é¥¥é¥¿**ï¼šçº¿ç¨‹é•¿æ—¶é—´æ— æ³•è·å¾—èµ„æº

### Q3: å¦‚ä½•ä¼˜åŒ–å¹¶å‘æ€§èƒ½ï¼Ÿ

**ç­”æ¡ˆï¼š**
1. å‡å°‘é”çš„ç²’åº¦
2. ä½¿ç”¨æ— é”æ•°æ®ç»“æ„
3. è¯»å†™åˆ†ç¦»
4. ä½¿ç”¨çº¿ç¨‹æ± 
5. æ‰¹é‡å¤„ç†

### Q4: ç”Ÿäº§ç¯å¢ƒå¦‚ä½•é…ç½®çº¿ç¨‹æ± ï¼Ÿ

**ç­”æ¡ˆï¼š**
- ä½¿ç”¨æœ‰ç•Œé˜Ÿåˆ—
- è®¾ç½®åˆç†çš„æ‹’ç»ç­–ç•¥
- è‡ªå®šä¹‰çº¿ç¨‹å·¥å‚ï¼ˆå‘½åã€å¼‚å¸¸å¤„ç†ï¼‰
- ç›‘æ§çº¿ç¨‹æ± çŠ¶æ€

### Q5: å¦‚ä½•æ£€æµ‹æ­»é”ï¼Ÿ

**ç­”æ¡ˆï¼š**
- ä½¿ç”¨jstackå·¥å…·
- ä½¿ç”¨ThreadMXBean.findDeadlockedThreads()
- å®šæœŸæ£€æµ‹å¹¶å‘Šè­¦

---

## ğŸ“– æ‰©å±•é˜…è¯»

- [Java Concurrency Best Practices](https://www.baeldung.com/java-concurrency-best-practices)
- [Thread Pool Best Practices](https://www.baeldung.com/java-thread-pool-best-practices)

---

**è¿”å›ï¼š** [07-Javaå¹¶å‘ç¼–ç¨‹](./07-Javaå¹¶å‘ç¼–ç¨‹.md)  
**ä¸Šä¸€ç« ï¼š** [07-08 - å¹¶å‘è®¾è®¡æ¨¡å¼](./07-08-å¹¶å‘è®¾è®¡æ¨¡å¼.md)

---

**æ­å–œå®ŒæˆJavaå¹¶å‘ç¼–ç¨‹å­¦ä¹ ï¼** ğŸ‰

