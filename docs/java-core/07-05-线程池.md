# çº¿ç¨‹æ±  (Thread Pool)

> æ·±å…¥ç†è§£Executoræ¡†æ¶å’ŒThreadPoolExecutorçš„å®ç°åŸç†ï¼ŒæŒæ¡çº¿ç¨‹æ± çš„ä½¿ç”¨å’Œæœ€ä½³å®è·µ

## ç›®å½•
- [1. ä¸ºä»€ä¹ˆéœ€è¦çº¿ç¨‹æ± ](#1-ä¸ºä»€ä¹ˆéœ€è¦çº¿ç¨‹æ± )
- [2. Executoræ¡†æ¶](#2-executoræ¡†æ¶)
- [3. ThreadPoolExecutorè¯¦è§£](#3-threadpoolexecutorè¯¦è§£)
- [4. çº¿ç¨‹æ± ç±»å‹](#4-çº¿ç¨‹æ± ç±»å‹)
- [5. çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹](#5-çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹)
- [6. æ‹’ç»ç­–ç•¥](#6-æ‹’ç»ç­–ç•¥)
- [7. çº¿ç¨‹æ± ç›‘æ§](#7-çº¿ç¨‹æ± ç›‘æ§)
- [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
- [9. é¢è¯•é«˜é¢‘é—®é¢˜](#9-é¢è¯•é«˜é¢‘é—®é¢˜)

---

## 1. ä¸ºä»€ä¹ˆéœ€è¦çº¿ç¨‹æ±  (Why Thread Pool?)

### 1.1 ç›´æ¥åˆ›å»ºçº¿ç¨‹çš„é—®é¢˜

```java
/**
 * ç›´æ¥åˆ›å»ºçº¿ç¨‹çš„é—®é¢˜
 * Problems with Direct Thread Creation
 */
public class DirectThreadCreation {
    public static void main(String[] args) {
        // é—®é¢˜1ï¼šé¢‘ç¹åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹ï¼Œå¼€é”€å¤§
        for (int i = 0; i < 1000; i++) {
            new Thread(() -> {
                // æ‰§è¡Œä»»åŠ¡
                doTask();
            }).start();
        }
        
        // é—®é¢˜2ï¼šæ— æ³•æ§åˆ¶çº¿ç¨‹æ•°é‡ï¼Œå¯èƒ½å¯¼è‡´èµ„æºè€—å°½
        // é—®é¢˜3ï¼šç¼ºä¹ç»Ÿä¸€ç®¡ç†ï¼Œéš¾ä»¥ç›‘æ§å’Œè°ƒä¼˜
    }
}
```

**ç›´æ¥åˆ›å»ºçº¿ç¨‹çš„é—®é¢˜ï¼š**
1. **èµ„æºæ¶ˆè€—å¤§** - åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹å¼€é”€å¤§
2. **èµ„æºä¸å¯æ§** - æ— æ³•é™åˆ¶çº¿ç¨‹æ•°é‡ï¼Œå¯èƒ½å¯¼è‡´ç³»ç»Ÿèµ„æºè€—å°½
3. **ç¼ºä¹ç®¡ç†** - éš¾ä»¥ç»Ÿä¸€ç®¡ç†ã€ç›‘æ§å’Œè°ƒä¼˜

### 1.2 çº¿ç¨‹æ± çš„ä¼˜åŠ¿

1. **èµ„æºå¤ç”¨** - çº¿ç¨‹å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œå‡å°‘åˆ›å»ºå’Œé”€æ¯çš„å¼€é”€
2. **èµ„æºå¯æ§** - å¯ä»¥é™åˆ¶çº¿ç¨‹æ•°é‡ï¼Œé˜²æ­¢èµ„æºè€—å°½
3. **ç»Ÿä¸€ç®¡ç†** - ä¾¿äºç›‘æ§ã€è°ƒä¼˜å’Œæ•…éšœæ’æŸ¥
4. **æé«˜å“åº”é€Ÿåº¦** - ä»»åŠ¡åˆ°è¾¾æ—¶ï¼Œçº¿ç¨‹å·²åˆ›å»ºå¥½ï¼Œå¯ä»¥ç«‹å³æ‰§è¡Œ

### 1.3 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

åœ¨ç®—åŠ›å¹³å°ä¸­ï¼Œçº¿ç¨‹æ± çš„åº”ç”¨åœºæ™¯ï¼š

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„çº¿ç¨‹æ± åº”ç”¨
 * Thread Pool Usage in Computing Platform
 */
public class PlatformThreadPool {
    
    // ä»»åŠ¡è°ƒåº¦çº¿ç¨‹æ± ï¼šå¤„ç†Nomadä»»åŠ¡çŠ¶æ€åŒæ­¥
    private ExecutorService taskSchedulerPool = Executors.newFixedThreadPool(
        Runtime.getRuntime().availableProcessors()
    );
    
    // èŠ‚ç‚¹ç›‘æ§çº¿ç¨‹æ± ï¼šå¹¶å‘é‡‡é›†å¤šä¸ªèŠ‚ç‚¹ä¿¡æ¯
    private ExecutorService nodeMonitorPool = Executors.newCachedThreadPool();
    
    // ç»“ç®—å¤„ç†çº¿ç¨‹æ± ï¼šæ‰¹é‡å¤„ç†é’±åŒ…æ“ä½œ
    private ExecutorService billingPool = new ThreadPoolExecutor(
        5, 10, 60L, TimeUnit.SECONDS,
        new LinkedBlockingQueue<>(1000),
        new ThreadFactoryBuilder().setNameFormat("billing-%d").build(),
        new ThreadPoolExecutor.CallerRunsPolicy()
    );
    
    public void scheduleTask() {
        taskSchedulerPool.submit(() -> {
            // ä»Nomadè·å–ä»»åŠ¡çŠ¶æ€
            // æ›´æ–°æ•°æ®åº“å’ŒES
        });
    }
}
```

---

## 2. Executoræ¡†æ¶ (Executor Framework)

### 2.1 æ¡†æ¶ç»“æ„

```
Executor (æ¥å£)
    â†“
ExecutorService (æ¥å£)
    â†“
AbstractExecutorService (æŠ½è±¡ç±»)
    â†“
ThreadPoolExecutor (å®ç°ç±»)
```

### 2.2 æ ¸å¿ƒæ¥å£

#### Executoræ¥å£

```java
/**
 * Executoræ¥å£ï¼šæ‰§è¡Œä»»åŠ¡çš„æŠ½è±¡
 * Executor Interface: Task Execution Abstraction
 */
public interface Executor {
    void execute(Runnable command);
}
```

#### ExecutorServiceæ¥å£

```java
/**
 * ExecutorServiceæ¥å£ï¼šæ‰©å±•Executorï¼Œæä¾›æ›´å¤šåŠŸèƒ½
 * ExecutorService Interface: Extended Executor
 */
public interface ExecutorService extends Executor {
    // æäº¤ä»»åŠ¡ï¼ˆæœ‰è¿”å›å€¼ï¼‰
    <T> Future<T> submit(Callable<T> task);
    <T> Future<T> submit(Runnable task, T result);
    Future<?> submit(Runnable task);
    
    // å…³é—­çº¿ç¨‹æ± 
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    
    // ç­‰å¾…ç»ˆæ­¢
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    
    // æ‰¹é‡æäº¤
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks);
    <T> T invokeAny(Collection<? extends Callable<T>> tasks);
}
```

### 2.3 ä½¿ç”¨ç¤ºä¾‹

```java
/**
 * ExecutorServiceä½¿ç”¨ç¤ºä¾‹
 * ExecutorService Usage Example
 */
public class ExecutorServiceDemo {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        
        // æäº¤Runnableä»»åŠ¡
        Future<?> future1 = executor.submit(() -> {
            System.out.println("æ‰§è¡Œä»»åŠ¡1");
        });
        
        // æäº¤Callableä»»åŠ¡ï¼ˆæœ‰è¿”å›å€¼ï¼‰
        Future<String> future2 = executor.submit(() -> {
            Thread.sleep(1000);
            return "ä»»åŠ¡2å®Œæˆ";
        });
        
        // è·å–è¿”å›å€¼
        String result = future2.get(); // é˜»å¡ç›´åˆ°ä»»åŠ¡å®Œæˆ
        System.out.println("ç»“æœ: " + result);
        
        // å…³é—­çº¿ç¨‹æ± 
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
    }
}
```

---

## 3. ThreadPoolExecutorè¯¦è§£ (ThreadPoolExecutor Details)

### 3.1 æ ¸å¿ƒå‚æ•°

```java
/**
 * ThreadPoolExecutoræ„é€ æ–¹æ³•
 * ThreadPoolExecutor Constructor
 */
public ThreadPoolExecutor(
    int corePoolSize,              // æ ¸å¿ƒçº¿ç¨‹æ•°
    int maximumPoolSize,           // æœ€å¤§çº¿ç¨‹æ•°
    long keepAliveTime,            // ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´
    TimeUnit unit,                 // æ—¶é—´å•ä½
    BlockingQueue<Runnable> workQueue,  // ä»»åŠ¡é˜Ÿåˆ—
    ThreadFactory threadFactory,   // çº¿ç¨‹å·¥å‚
    RejectedExecutionHandler handler     // æ‹’ç»ç­–ç•¥
)
```

### 3.2 å‚æ•°è¯¦è§£

#### corePoolSizeï¼ˆæ ¸å¿ƒçº¿ç¨‹æ•°ï¼‰

- **å®šä¹‰**ï¼šçº¿ç¨‹æ± ä¸­ä¿æŒå­˜æ´»çš„æœ€å°çº¿ç¨‹æ•°
- **ç‰¹ç‚¹**ï¼šå³ä½¿ç©ºé—²ä¹Ÿä¸ä¼šè¢«å›æ”¶ï¼ˆé™¤éallowCoreThreadTimeOut=trueï¼‰
- **è®¾ç½®å»ºè®®**ï¼šCPUå¯†é›†å‹ä»»åŠ¡ï¼šCPUæ ¸å¿ƒæ•°ï¼›IOå¯†é›†å‹ä»»åŠ¡ï¼šCPUæ ¸å¿ƒæ•° * 2

#### maximumPoolSizeï¼ˆæœ€å¤§çº¿ç¨‹æ•°ï¼‰

- **å®šä¹‰**ï¼šçº¿ç¨‹æ± å…è®¸çš„æœ€å¤§çº¿ç¨‹æ•°
- **ç‰¹ç‚¹**ï¼šå½“é˜Ÿåˆ—æ»¡ä¸”æ ¸å¿ƒçº¿ç¨‹éƒ½åœ¨å¿™æ—¶ï¼Œä¼šåˆ›å»ºæ–°çº¿ç¨‹ï¼ˆä¸è¶…è¿‡æœ€å¤§å€¼ï¼‰
- **è®¾ç½®å»ºè®®**ï¼šæ ¹æ®ä¸šåŠ¡åœºæ™¯å’Œç³»ç»Ÿèµ„æºè®¾ç½®

#### keepAliveTimeï¼ˆç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´ï¼‰

- **å®šä¹‰**ï¼šéæ ¸å¿ƒçº¿ç¨‹ç©ºé—²æ—¶çš„å­˜æ´»æ—¶é—´
- **ç‰¹ç‚¹**ï¼šè¶…è¿‡æ­¤æ—¶é—´ï¼Œéæ ¸å¿ƒçº¿ç¨‹ä¼šè¢«å›æ”¶
- **è®¾ç½®å»ºè®®**ï¼šæ ¹æ®ä»»åŠ¡ç‰¹ç‚¹è®¾ç½®ï¼Œé¿å…é¢‘ç¹åˆ›å»ºé”€æ¯çº¿ç¨‹

#### workQueueï¼ˆä»»åŠ¡é˜Ÿåˆ—ï¼‰

- **å®šä¹‰**ï¼šç”¨äºå­˜æ”¾å¾…æ‰§è¡Œä»»åŠ¡çš„é˜»å¡é˜Ÿåˆ—
- **å¸¸ç”¨é˜Ÿåˆ—**ï¼š
  - `LinkedBlockingQueue` - æ— ç•Œé˜Ÿåˆ—ï¼ˆå¯èƒ½å¯¼è‡´OOMï¼‰
  - `ArrayBlockingQueue` - æœ‰ç•Œé˜Ÿåˆ—ï¼ˆéœ€è¦æŒ‡å®šå¤§å°ï¼‰
  - `SynchronousQueue` - åŒæ­¥é˜Ÿåˆ—ï¼ˆä¸å­˜å‚¨å…ƒç´ ï¼‰
  - `PriorityBlockingQueue` - ä¼˜å…ˆçº§é˜Ÿåˆ—

#### threadFactoryï¼ˆçº¿ç¨‹å·¥å‚ï¼‰

- **å®šä¹‰**ï¼šç”¨äºåˆ›å»ºçº¿ç¨‹çš„å·¥å‚
- **ä½œç”¨**ï¼šå¯ä»¥è‡ªå®šä¹‰çº¿ç¨‹åç§°ã€ä¼˜å…ˆçº§ã€æ˜¯å¦ä¸ºå®ˆæŠ¤çº¿ç¨‹ç­‰

```java
ThreadFactory factory = new ThreadFactoryBuilder()
    .setNameFormat("task-%d")
    .setDaemon(false)
    .setPriority(Thread.NORM_PRIORITY)
    .build();
```

#### handlerï¼ˆæ‹’ç»ç­–ç•¥ï¼‰

- **å®šä¹‰**ï¼šå½“çº¿ç¨‹æ± å’Œé˜Ÿåˆ—éƒ½æ»¡æ—¶ï¼Œå¦‚ä½•å¤„ç†æ–°ä»»åŠ¡
- **ç­–ç•¥ç±»å‹**ï¼šè§[6. æ‹’ç»ç­–ç•¥](#6-æ‹’ç»ç­–ç•¥)

### 3.3 çº¿ç¨‹æ± çŠ¶æ€

```java
/**
 * çº¿ç¨‹æ± çŠ¶æ€ï¼ˆä½¿ç”¨AtomicIntegerçš„ctlå­—æ®µå­˜å‚¨ï¼‰
 * Thread Pool States
 */
private static final int RUNNING    = -1 << COUNT_BITS; // è¿è¡Œä¸­
private static final int SHUTDOWN   =  0 << COUNT_BITS; // å…³é—­ä¸­
private static final int STOP       =  1 << COUNT_BITS; // åœæ­¢
private static final int TIDYING    =  2 << COUNT_BITS; // æ•´ç†ä¸­
private static final int TERMINATED =  3 << COUNT_BITS; // å·²ç»ˆæ­¢
```

**çŠ¶æ€è½¬æ¢ï¼š**
```
RUNNING â†’ SHUTDOWN â†’ STOP â†’ TIDYING â†’ TERMINATED
```

---

## 4. çº¿ç¨‹æ± ç±»å‹ (Thread Pool Types)

### 4.1 FixedThreadPoolï¼ˆå›ºå®šçº¿ç¨‹æ± ï¼‰

```java
/**
 * FixedThreadPoolï¼šå›ºå®šå¤§å°çš„çº¿ç¨‹æ± 
 * FixedThreadPool: Fixed Size Thread Pool
 */
ExecutorService executor = Executors.newFixedThreadPool(5);
```

**ç‰¹ç‚¹ï¼š**
- æ ¸å¿ƒçº¿ç¨‹æ•° = æœ€å¤§çº¿ç¨‹æ•° = æŒ‡å®šå¤§å°
- ä½¿ç”¨æ— ç•Œé˜Ÿåˆ—`LinkedBlockingQueue`
- é€‚ç”¨äºCPUå¯†é›†å‹ä»»åŠ¡

**æºç ï¼š**
```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(
        nThreads, nThreads,
        0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>()  // æ— ç•Œé˜Ÿåˆ—
    );
}
```

### 4.2 CachedThreadPoolï¼ˆç¼“å­˜çº¿ç¨‹æ± ï¼‰

```java
/**
 * CachedThreadPoolï¼šå¯ç¼“å­˜çš„çº¿ç¨‹æ± 
 * CachedThreadPool: Cached Thread Pool
 */
ExecutorService executor = Executors.newCachedThreadPool();
```

**ç‰¹ç‚¹ï¼š**
- æ ¸å¿ƒçº¿ç¨‹æ•°ä¸º0ï¼Œæœ€å¤§çº¿ç¨‹æ•°ä¸ºInteger.MAX_VALUE
- ä½¿ç”¨`SynchronousQueue`ï¼ˆä¸å­˜å‚¨å…ƒç´ ï¼‰
- çº¿ç¨‹ç©ºé—²60ç§’åå›æ”¶
- é€‚ç”¨äºçŸ­æ—¶ä»»åŠ¡ã€IOå¯†é›†å‹ä»»åŠ¡

**æºç ï¼š**
```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(
        0, Integer.MAX_VALUE,
        60L, TimeUnit.SECONDS,
        new SynchronousQueue<Runnable>()  // åŒæ­¥é˜Ÿåˆ—
    );
}
```

### 4.3 SingleThreadExecutorï¼ˆå•çº¿ç¨‹æ± ï¼‰

```java
/**
 * SingleThreadExecutorï¼šå•çº¿ç¨‹æ‰§è¡Œå™¨
 * SingleThreadExecutor: Single Thread Executor
 */
ExecutorService executor = Executors.newSingleThreadExecutor();
```

**ç‰¹ç‚¹ï¼š**
- æ ¸å¿ƒçº¿ç¨‹æ•° = æœ€å¤§çº¿ç¨‹æ•° = 1
- ä½¿ç”¨æ— ç•Œé˜Ÿåˆ—`LinkedBlockingQueue`
- ä¿è¯ä»»åŠ¡é¡ºåºæ‰§è¡Œ
- é€‚ç”¨äºéœ€è¦é¡ºåºæ‰§è¡Œä»»åŠ¡çš„åœºæ™¯

### 4.4 ScheduledThreadPoolï¼ˆå®šæ—¶çº¿ç¨‹æ± ï¼‰

```java
/**
 * ScheduledThreadPoolï¼šå®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± 
 * ScheduledThreadPool: Scheduled Task Thread Pool
 */
ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);

// å»¶è¿Ÿæ‰§è¡Œ
executor.schedule(() -> {
    System.out.println("å»¶è¿Ÿæ‰§è¡Œ");
}, 5, TimeUnit.SECONDS);

// å®šæ—¶æ‰§è¡Œ
executor.scheduleAtFixedRate(() -> {
    System.out.println("å®šæ—¶æ‰§è¡Œ");
}, 0, 1, TimeUnit.SECONDS);
```

**ç‰¹ç‚¹ï¼š**
- æ”¯æŒå»¶è¿Ÿæ‰§è¡Œå’Œå®šæ—¶æ‰§è¡Œ
- ä½¿ç”¨`DelayedWorkQueue`ï¼ˆä¼˜å…ˆçº§é˜Ÿåˆ—ï¼‰
- é€‚ç”¨äºå®šæ—¶ä»»åŠ¡ã€å‘¨æœŸæ€§ä»»åŠ¡

### 4.5 çº¿ç¨‹æ± ç±»å‹å¯¹æ¯”

| çº¿ç¨‹æ± ç±»å‹ | æ ¸å¿ƒçº¿ç¨‹æ•° | æœ€å¤§çº¿ç¨‹æ•° | é˜Ÿåˆ—ç±»å‹ | é€‚ç”¨åœºæ™¯ |
|-----------|----------|----------|---------|---------|
| **FixedThreadPool** | å›ºå®š | å›ºå®š | LinkedBlockingQueue | CPUå¯†é›†å‹ |
| **CachedThreadPool** | 0 | Integer.MAX_VALUE | SynchronousQueue | çŸ­æ—¶ä»»åŠ¡ã€IOå¯†é›†å‹ |
| **SingleThreadExecutor** | 1 | 1 | LinkedBlockingQueue | é¡ºåºæ‰§è¡Œ |
| **ScheduledThreadPool** | æŒ‡å®š | Integer.MAX_VALUE | DelayedWorkQueue | å®šæ—¶ä»»åŠ¡ |

---

## 5. çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹ (Execution Flow)

### 5.1 æ‰§è¡Œæµç¨‹å›¾

```
æäº¤ä»»åŠ¡ (execute/submit)
    â†“
æ ¸å¿ƒçº¿ç¨‹æ˜¯å¦å·²æ»¡ï¼Ÿ
    â”œâ”€ å¦ â†’ åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
    â””â”€ æ˜¯ â†’ ä»»åŠ¡é˜Ÿåˆ—æ˜¯å¦å·²æ»¡ï¼Ÿ
            â”œâ”€ å¦ â†’ åŠ å…¥é˜Ÿåˆ—ç­‰å¾…
            â””â”€ æ˜¯ â†’ æœ€å¤§çº¿ç¨‹æ•°æ˜¯å¦å·²æ»¡ï¼Ÿ
                    â”œâ”€ å¦ â†’ åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
                    â””â”€ æ˜¯ â†’ æ‰§è¡Œæ‹’ç»ç­–ç•¥
```

### 5.2 æºç åˆ†æ

```java
/**
 * ThreadPoolExecutor.execute()æ–¹æ³•æ ¸å¿ƒé€»è¾‘
 * Core Logic of ThreadPoolExecutor.execute()
 */
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    
    int c = ctl.get();
    
    // 1. å¦‚æœå½“å‰çº¿ç¨‹æ•° < æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œåˆ›å»ºæ ¸å¿ƒçº¿ç¨‹
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    
    // 2. å¦‚æœçº¿ç¨‹æ± è¿è¡Œä¸­ä¸”ä»»åŠ¡å¯ä»¥åŠ å…¥é˜Ÿåˆ—
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // å†æ¬¡æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
        if (!isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 3. å¦‚æœé˜Ÿåˆ—æ»¡ï¼Œå°è¯•åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹
    else if (!addWorker(command, false))
        // 4. å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œæ‰§è¡Œæ‹’ç»ç­–ç•¥
        reject(command);
}
```

### 5.3 ç¤ºä¾‹è¯´æ˜

```java
/**
 * çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹ç¤ºä¾‹
 * Execution Flow Example
 */
public class ExecutionFlowDemo {
    public static void main(String[] args) {
        // åˆ›å»ºçº¿ç¨‹æ± ï¼šæ ¸å¿ƒ2ï¼Œæœ€å¤§4ï¼Œé˜Ÿåˆ—å®¹é‡2
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new ThreadPoolExecutor.AbortPolicy()
        );
        
        // æäº¤6ä¸ªä»»åŠ¡
        for (int i = 1; i <= 6; i++) {
            final int taskId = i;
            executor.execute(() -> {
                System.out.println("ä»»åŠ¡" + taskId + "æ‰§è¡Œ");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        // æ‰§è¡Œæµç¨‹ï¼š
        // ä»»åŠ¡1ã€2 â†’ æ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
        // ä»»åŠ¡3ã€4 â†’ åŠ å…¥é˜Ÿåˆ—
        // ä»»åŠ¡5ã€6 â†’ åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
        // å¦‚æœè¿˜æœ‰ä»»åŠ¡ â†’ æ‹’ç»ç­–ç•¥
    }
}
```

---

## 6. æ‹’ç»ç­–ç•¥ (Rejection Policy)

### 6.1 å†…ç½®æ‹’ç»ç­–ç•¥

#### AbortPolicyï¼ˆé»˜è®¤ç­–ç•¥ï¼‰

```java
/**
 * AbortPolicyï¼šç›´æ¥æŠ›å‡ºå¼‚å¸¸
 * AbortPolicy: Throw Exception
 */
new ThreadPoolExecutor.AbortPolicy()
```

**è¡Œä¸ºï¼š** ç›´æ¥æŠ›å‡º`RejectedExecutionException`å¼‚å¸¸

#### CallerRunsPolicyï¼ˆè°ƒç”¨è€…è¿è¡Œç­–ç•¥ï¼‰

```java
/**
 * CallerRunsPolicyï¼šè°ƒç”¨è€…çº¿ç¨‹æ‰§è¡Œ
 * CallerRunsPolicy: Caller Runs
 */
new ThreadPoolExecutor.CallerRunsPolicy()
```

**è¡Œä¸ºï¼š** åœ¨è°ƒç”¨è€…çº¿ç¨‹ä¸­æ‰§è¡Œä»»åŠ¡ï¼ˆä¼šé˜»å¡è°ƒç”¨è€…ï¼‰

#### DiscardPolicyï¼ˆä¸¢å¼ƒç­–ç•¥ï¼‰

```java
/**
 * DiscardPolicyï¼šç›´æ¥ä¸¢å¼ƒä»»åŠ¡
 * DiscardPolicy: Discard Task
 */
new ThreadPoolExecutor.DiscardPolicy()
```

**è¡Œä¸ºï¼š** é™é»˜ä¸¢å¼ƒä»»åŠ¡ï¼Œä¸æŠ›å¼‚å¸¸

#### DiscardOldestPolicyï¼ˆä¸¢å¼ƒæœ€è€ä»»åŠ¡ï¼‰

```java
/**
 * DiscardOldestPolicyï¼šä¸¢å¼ƒé˜Ÿåˆ—æœ€è€çš„ä»»åŠ¡
 * DiscardOldestPolicy: Discard Oldest Task
 */
new ThreadPoolExecutor.DiscardOldestPolicy()
```

**è¡Œä¸ºï¼š** ä¸¢å¼ƒé˜Ÿåˆ—å¤´éƒ¨çš„ä»»åŠ¡ï¼Œç„¶åå°è¯•æ‰§è¡Œæ–°ä»»åŠ¡

### 6.2 è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥

```java
/**
 * è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥ï¼šè®°å½•æ—¥å¿—å¹¶ä¿å­˜åˆ°æ•°æ®åº“
 * Custom Rejection Policy
 */
public class CustomRejectionPolicy implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // è®°å½•æ—¥å¿—
        logger.warn("ä»»åŠ¡è¢«æ‹’ç»: " + r.toString());
        
        // ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆå¼‚æ­¥ï¼‰
        saveToDatabase(r);
        
        // æˆ–è€…å‘é€å‘Šè­¦
        sendAlert("çº¿ç¨‹æ± ä»»åŠ¡è¢«æ‹’ç»");
    }
}
```

### 6.3 æ‹’ç»ç­–ç•¥å¯¹æ¯”

| ç­–ç•¥ | è¡Œä¸º | é€‚ç”¨åœºæ™¯ |
|------|------|---------|
| **AbortPolicy** | æŠ›å¼‚å¸¸ | éœ€è¦çŸ¥é“ä»»åŠ¡è¢«æ‹’ç» |
| **CallerRunsPolicy** | è°ƒç”¨è€…æ‰§è¡Œ | å¯ä»¥æ¥å—é™çº§å¤„ç† |
| **DiscardPolicy** | é™é»˜ä¸¢å¼ƒ | å¯ä»¥å®¹å¿ä»»åŠ¡ä¸¢å¤± |
| **DiscardOldestPolicy** | ä¸¢å¼ƒæœ€è€ä»»åŠ¡ | ä¼˜å…ˆå¤„ç†æ–°ä»»åŠ¡ |

---

## 7. çº¿ç¨‹æ± ç›‘æ§ (Thread Pool Monitoring)

### 7.1 ç›‘æ§æŒ‡æ ‡

```java
/**
 * çº¿ç¨‹æ± ç›‘æ§ç¤ºä¾‹
 * Thread Pool Monitoring Example
 */
public class ThreadPoolMonitor {
    public void monitor(ThreadPoolExecutor executor) {
        // æ ¸å¿ƒçº¿ç¨‹æ•°
        int corePoolSize = executor.getCorePoolSize();
        
        // æœ€å¤§çº¿ç¨‹æ•°
        int maximumPoolSize = executor.getMaximumPoolSize();
        
        // å½“å‰çº¿ç¨‹æ•°
        int poolSize = executor.getPoolSize();
        
        // æ´»è·ƒçº¿ç¨‹æ•°
        int activeCount = executor.getActiveCount();
        
        // å·²å®Œæˆä»»åŠ¡æ•°
        long completedTaskCount = executor.getCompletedTaskCount();
        
        // æ€»ä»»åŠ¡æ•°
        long taskCount = executor.getTaskCount();
        
        // é˜Ÿåˆ—å¤§å°
        int queueSize = executor.getQueue().size();
        
        // æ‰“å°ç›‘æ§ä¿¡æ¯
        System.out.println(String.format(
            "çº¿ç¨‹æ± ç›‘æ§ - æ ¸å¿ƒ:%d, æœ€å¤§:%d, å½“å‰:%d, æ´»è·ƒ:%d, å·²å®Œæˆ:%d, æ€»ä»»åŠ¡:%d, é˜Ÿåˆ—:%d",
            corePoolSize, maximumPoolSize, poolSize, activeCount,
            completedTaskCount, taskCount, queueSize
        ));
    }
}
```

### 7.2 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

```java
/**
 * ç®—åŠ›å¹³å°çº¿ç¨‹æ± ç›‘æ§
 * Computing Platform Thread Pool Monitoring
 */
@Component
public class PlatformThreadPoolMonitor {
    
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿç›‘æ§ä¸€æ¬¡
    public void monitor() {
        // ç›‘æ§ä»»åŠ¡è°ƒåº¦çº¿ç¨‹æ± 
        monitorThreadPool(taskSchedulerPool, "ä»»åŠ¡è°ƒåº¦çº¿ç¨‹æ± ");
        
        // ç›‘æ§ç»“ç®—å¤„ç†çº¿ç¨‹æ± 
        monitorThreadPool(billingPool, "ç»“ç®—å¤„ç†çº¿ç¨‹æ± ");
    }
    
    private void monitorThreadPool(ThreadPoolExecutor executor, String name) {
        int queueSize = executor.getQueue().size();
        int activeCount = executor.getActiveCount();
        
        // å‘Šè­¦ï¼šé˜Ÿåˆ—ç§¯å‹
        if (queueSize > 1000) {
            logger.warn("{}é˜Ÿåˆ—ç§¯å‹: {}", name, queueSize);
        }
        
        // å‘Šè­¦ï¼šçº¿ç¨‹æ± æ»¡è½½
        if (activeCount == executor.getMaximumPoolSize()) {
            logger.warn("{}çº¿ç¨‹æ± æ»¡è½½", name);
        }
    }
}
```

---

## 8. æœ€ä½³å®è·µ (Best Practices)

### 8.1 çº¿ç¨‹æ± å‚æ•°è®¾ç½®

```java
/**
 * çº¿ç¨‹æ± å‚æ•°è®¾ç½®å»ºè®®
 * Thread Pool Parameter Configuration
 */
public class ThreadPoolConfig {
    
    // CPUå¯†é›†å‹ä»»åŠ¡
    public static ThreadPoolExecutor createCpuIntensivePool() {
        int corePoolSize = Runtime.getRuntime().availableProcessors();
        return new ThreadPoolExecutor(
            corePoolSize,
            corePoolSize,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<>(1000),
            new ThreadFactoryBuilder().setNameFormat("cpu-%d").build(),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
    
    // IOå¯†é›†å‹ä»»åŠ¡
    public static ThreadPoolExecutor createIoIntensivePool() {
        int corePoolSize = Runtime.getRuntime().availableProcessors() * 2;
        return new ThreadPoolExecutor(
            corePoolSize,
            corePoolSize * 2,
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000),
            new ThreadFactoryBuilder().setNameFormat("io-%d").build(),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
}
```

### 8.2 æ­£ç¡®å…³é—­çº¿ç¨‹æ± 

```java
/**
 * æ­£ç¡®å…³é—­çº¿ç¨‹æ± 
 * Proper Thread Pool Shutdown
 */
public void shutdownThreadPool(ExecutorService executor) {
    executor.shutdown(); // åœæ­¢æ¥æ”¶æ–°ä»»åŠ¡
    
    try {
        // ç­‰å¾…å·²æäº¤çš„ä»»åŠ¡å®Œæˆ
        if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
            // è¶…æ—¶åå¼ºåˆ¶å…³é—­
            executor.shutdownNow();
            
            // å†æ¬¡ç­‰å¾…
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                logger.error("çº¿ç¨‹æ± æœªèƒ½æ­£å¸¸å…³é—­");
            }
        }
    } catch (InterruptedException e) {
        executor.shutdownNow();
        Thread.currentThread().interrupt();
    }
}
```

### 8.3 ä½¿ç”¨æœ‰ç•Œé˜Ÿåˆ—

```java
// âŒ ä¸æ¨èï¼šæ— ç•Œé˜Ÿåˆ—å¯èƒ½å¯¼è‡´OOM
new ThreadPoolExecutor(5, 10, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>()  // æ— ç•Œé˜Ÿåˆ—
);

// âœ… æ¨èï¼šä½¿ç”¨æœ‰ç•Œé˜Ÿåˆ—
new ThreadPoolExecutor(5, 10, 60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(1000),  // æœ‰ç•Œé˜Ÿåˆ—
    new ThreadPoolExecutor.CallerRunsPolicy()  // æ‹’ç»ç­–ç•¥
);
```

### 8.4 è‡ªå®šä¹‰çº¿ç¨‹å·¥å‚

```java
/**
 * è‡ªå®šä¹‰çº¿ç¨‹å·¥å‚ï¼šä¾¿äºé—®é¢˜æ’æŸ¥
 * Custom Thread Factory
 */
ThreadFactory factory = new ThreadFactoryBuilder()
    .setNameFormat("task-pool-%d")  // çº¿ç¨‹åç§°æ ¼å¼
    .setDaemon(false)               // éå®ˆæŠ¤çº¿ç¨‹
    .setPriority(Thread.NORM_PRIORITY)  // æ­£å¸¸ä¼˜å…ˆçº§
    .setUncaughtExceptionHandler((t, e) -> {
        logger.error("çº¿ç¨‹{}æœªæ•è·å¼‚å¸¸", t.getName(), e);
    })
    .build();
```

---

## 9. é¢è¯•é«˜é¢‘é—®é¢˜ (Interview Questions)

### Q1: çº¿ç¨‹æ± çš„æ ¸å¿ƒå‚æ•°æœ‰å“ªäº›ï¼Ÿ

**ç­”æ¡ˆï¼š** corePoolSizeã€maximumPoolSizeã€keepAliveTimeã€workQueueã€threadFactoryã€handler

### Q2: çº¿ç¨‹æ± çš„æ‰§è¡Œæµç¨‹ï¼Ÿ

**ç­”æ¡ˆï¼š** è§[5. çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹](#5-çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹)

### Q3: å¦‚ä½•åˆç†è®¾ç½®çº¿ç¨‹æ± å‚æ•°ï¼Ÿ

**ç­”æ¡ˆï¼š**
- CPUå¯†é›†å‹ï¼šæ ¸å¿ƒçº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•°
- IOå¯†é›†å‹ï¼šæ ¸å¿ƒçº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° * 2
- ä½¿ç”¨æœ‰ç•Œé˜Ÿåˆ—ï¼Œè®¾ç½®åˆç†çš„æ‹’ç»ç­–ç•¥

### Q4: çº¿ç¨‹æ± çš„æ‹’ç»ç­–ç•¥æœ‰å“ªäº›ï¼Ÿ

**ç­”æ¡ˆï¼š** AbortPolicyã€CallerRunsPolicyã€DiscardPolicyã€DiscardOldestPolicy

### Q5: å¦‚ä½•ç›‘æ§çº¿ç¨‹æ± ï¼Ÿ

**ç­”æ¡ˆï¼š** ç›‘æ§æ ¸å¿ƒçº¿ç¨‹æ•°ã€æœ€å¤§çº¿ç¨‹æ•°ã€å½“å‰çº¿ç¨‹æ•°ã€æ´»è·ƒçº¿ç¨‹æ•°ã€é˜Ÿåˆ—å¤§å°ã€å·²å®Œæˆä»»åŠ¡æ•°ç­‰æŒ‡æ ‡

---

## ğŸ“– æ‰©å±•é˜…è¯»

- [ThreadPoolExecutor API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html)
- [Java Concurrency in Practice](https://jcip.net/)

---

**è¿”å›ï¼š** [07-Javaå¹¶å‘ç¼–ç¨‹](./07-Javaå¹¶å‘ç¼–ç¨‹.md)  
**ä¸Šä¸€ç« ï¼š** [07-04 - å¹¶å‘å·¥å…·ç±»](./07-04-å¹¶å‘å·¥å…·ç±».md)  
**ä¸‹ä¸€ç« ï¼š** [07-06 - å¹¶å‘é›†åˆ â†’](./07-06-å¹¶å‘é›†åˆ.md)

