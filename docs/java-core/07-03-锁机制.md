# é”æœºåˆ¶ (Lock Mechanism)

> æ·±å…¥ç†è§£ReentrantLockã€ReadWriteLockã€StampedLockç­‰æ˜¾å¼é”çš„å®ç°åŸç†å’Œä½¿ç”¨åœºæ™¯

## ç›®å½•
- [1. ä¸ºä»€ä¹ˆéœ€è¦æ˜¾å¼é”](#1-ä¸ºä»€ä¹ˆéœ€è¦æ˜¾å¼é”)
- [2. ReentrantLock](#2-reentrantlock)
- [3. ReadWriteLock](#3-readwritelock)
- [4. StampedLock](#4-stampedlock)
- [5. é”çš„æ€§èƒ½å¯¹æ¯”](#5-é”çš„æ€§èƒ½å¯¹æ¯”)
- [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
- [7. é¢è¯•é«˜é¢‘é—®é¢˜](#7-é¢è¯•é«˜é¢‘é—®é¢˜)

---

## 1. ä¸ºä»€ä¹ˆéœ€è¦æ˜¾å¼é” (Why Explicit Locks?)

### 1.1 synchronizedçš„å±€é™æ€§

è™½ç„¶`synchronized`å…³é”®å­—ç®€å•æ˜“ç”¨ï¼Œä½†åœ¨æŸäº›åœºæ™¯ä¸‹å­˜åœ¨å±€é™æ€§ï¼š

1. **æ— æ³•ä¸­æ–­** - è·å–é”çš„çº¿ç¨‹æ— æ³•è¢«ä¸­æ–­
2. **æ— æ³•è¶…æ—¶** - æ— æ³•è®¾ç½®è·å–é”çš„è¶…æ—¶æ—¶é—´
3. **éå…¬å¹³é”** - é»˜è®¤æ˜¯éå…¬å¹³é”ï¼Œå¯èƒ½å¯¼è‡´çº¿ç¨‹é¥¥é¥¿
4. **åŠŸèƒ½å•ä¸€** - åªæœ‰ä¸€ç§é”æ¨¡å¼ï¼Œæ— æ³•å®ç°è¯»å†™åˆ†ç¦»

### 1.2 æ˜¾å¼é”çš„ä¼˜åŠ¿

**æ˜¾å¼é”ï¼ˆExplicit Lockï¼‰**æä¾›äº†æ›´çµæ´»çš„é”æœºåˆ¶ï¼š

- **å¯ä¸­æ–­** - å¯ä»¥å“åº”ä¸­æ–­
- **å¯è¶…æ—¶** - å¯ä»¥è®¾ç½®è¶…æ—¶æ—¶é—´
- **å…¬å¹³é”** - æ”¯æŒå…¬å¹³é”å’Œéå…¬å¹³é”
- **è¯»å†™åˆ†ç¦»** - ReadWriteLockæ”¯æŒè¯»å†™åˆ†ç¦»
- **æ¡ä»¶å˜é‡** - æ”¯æŒå¤šä¸ªæ¡ä»¶å˜é‡

### 1.3 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

åœ¨ç®—åŠ›å¹³å°çš„ç»“ç®—ç³»ç»Ÿä¸­ï¼Œéœ€è¦æ›´çµæ´»çš„é”æœºåˆ¶ï¼š

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„é”åº”ç”¨åœºæ™¯
 * Lock Usage in Computing Platform
 */
public class PlatformLock {
    
    // åœºæ™¯1ï¼šéœ€è¦è¶…æ—¶çš„é”æ“ä½œ
    private ReentrantLock billingLock = new ReentrantLock();
    
    public boolean tryDeduct(Long userId, Long amount, long timeout) {
        try {
            // å°è¯•è·å–é”ï¼Œè®¾ç½®è¶…æ—¶æ—¶é—´
            if (billingLock.tryLock(timeout, TimeUnit.SECONDS)) {
                try {
                    // æ‰§è¡Œæ‰£è´¹æ“ä½œ
                    return deduct(userId, amount);
                } finally {
                    billingLock.unlock();
                }
            }
            return false; // è¶…æ—¶æœªè·å–åˆ°é”
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
    
    // åœºæ™¯2ï¼šè¯»å†™åˆ†ç¦»çš„åœºæ™¯
    private ReadWriteLock configLock = new ReentrantReadWriteLock();
    
    public String getConfig(String key) {
        configLock.readLock().lock(); // è¯»é”
        try {
            return configMap.get(key);
        } finally {
            configLock.readLock().unlock();
        }
    }
    
    public void updateConfig(String key, String value) {
        configLock.writeLock().lock(); // å†™é”
        try {
            configMap.put(key, value);
        } finally {
            configLock.writeLock().unlock();
        }
    }
}
```

---

## 2. ReentrantLock (ReentrantLock)

### 2.1 æ ¸å¿ƒç‰¹ç‚¹

**ReentrantLockï¼ˆå¯é‡å…¥é”ï¼‰**æ˜¯`java.util.concurrent.locks`åŒ…ä¸­æœ€å¸¸ç”¨çš„é”å®ç°ã€‚

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **å¯é‡å…¥** | åŒä¸€çº¿ç¨‹å¯ä»¥å¤šæ¬¡è·å–é” |
| **å¯ä¸­æ–­** | æ”¯æŒä¸­æ–­è·å–é”çš„æ“ä½œ |
| **å¯è¶…æ—¶** | æ”¯æŒè¶…æ—¶è·å–é” |
| **å…¬å¹³é”** | æ”¯æŒå…¬å¹³é”å’Œéå…¬å¹³é” |

### 2.2 åŸºæœ¬ä½¿ç”¨

```java
import java.util.concurrent.locks.ReentrantLock;

/**
 * ReentrantLockåŸºæœ¬ä½¿ç”¨
 * Basic Usage of ReentrantLock
 */
public class ReentrantLockDemo {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;
    
    public void increment() {
        lock.lock(); // è·å–é”
        try {
            count++;
        } finally {
            lock.unlock(); // é‡Šæ”¾é”ï¼ˆå¿…é¡»åœ¨finallyä¸­ï¼‰
        }
    }
    
    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}
```

**å…³é”®ç‚¹ï¼š**
- `lock()` - è·å–é”ï¼Œå¦‚æœé”è¢«å ç”¨åˆ™é˜»å¡
- `unlock()` - é‡Šæ”¾é”ï¼Œå¿…é¡»åœ¨`finally`å—ä¸­è°ƒç”¨
- å¿…é¡»æ‰‹åŠ¨é‡Šæ”¾é”ï¼Œå¦åˆ™ä¼šå¯¼è‡´æ­»é”

### 2.3 å¯ä¸­æ–­é”

```java
/**
 * å¯ä¸­æ–­é”ç¤ºä¾‹
 * Interruptible Lock Example
 */
public class InterruptibleLockDemo {
    private final ReentrantLock lock = new ReentrantLock();
    
    public void interruptibleMethod() throws InterruptedException {
        lock.lockInterruptibly(); // å¯ä¸­æ–­çš„è·å–é”
        try {
            // æ‰§è¡Œä»»åŠ¡
            while (true) {
                // å¦‚æœè¢«ä¸­æ–­ï¼Œä¼šæŠ›å‡ºInterruptedException
                Thread.sleep(1000);
            }
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        InterruptibleLockDemo demo = new InterruptibleLockDemo();
        Thread thread = new Thread(() -> {
            try {
                demo.interruptibleMethod();
            } catch (InterruptedException e) {
                System.out.println("çº¿ç¨‹è¢«ä¸­æ–­");
            }
        });
        
        thread.start();
        thread.interrupt(); // ä¸­æ–­çº¿ç¨‹
    }
}
```

### 2.4 è¶…æ—¶é”

```java
/**
 * è¶…æ—¶é”ç¤ºä¾‹
 * Timeout Lock Example
 */
public class TimeoutLockDemo {
    private final ReentrantLock lock = new ReentrantLock();
    
    public boolean tryLockWithTimeout(long timeout, TimeUnit unit) {
        try {
            // å°è¯•è·å–é”ï¼Œè®¾ç½®è¶…æ—¶æ—¶é—´
            if (lock.tryLock(timeout, unit)) {
                try {
                    // æ‰§è¡Œä»»åŠ¡
                    doSomething();
                    return true;
                } finally {
                    lock.unlock();
                }
            }
            return false; // è¶…æ—¶æœªè·å–åˆ°é”
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
}
```

### 2.5 å…¬å¹³é” vs éå…¬å¹³é”

```java
/**
 * å…¬å¹³é” vs éå…¬å¹³é”
 * Fair Lock vs Non-Fair Lock
 */
public class FairLockDemo {
    // å…¬å¹³é”ï¼šæŒ‰ç…§è¯·æ±‚é”çš„é¡ºåºåˆ†é…é”
    private ReentrantLock fairLock = new ReentrantLock(true);
    
    // éå…¬å¹³é”ï¼šä¸ä¿è¯é¡ºåºï¼ˆé»˜è®¤ï¼Œæ€§èƒ½æ›´å¥½ï¼‰
    private ReentrantLock nonFairLock = new ReentrantLock(false);
    
    public void fairMethod() {
        fairLock.lock();
        try {
            // å…¬å¹³é”ï¼šä¿è¯å…ˆè¯·æ±‚çš„çº¿ç¨‹å…ˆè·å¾—é”
        } finally {
            fairLock.unlock();
        }
    }
    
    public void nonFairMethod() {
        nonFairLock.lock();
        try {
            // éå…¬å¹³é”ï¼šå¯èƒ½åè¯·æ±‚çš„çº¿ç¨‹å…ˆè·å¾—é”ï¼ˆæ€§èƒ½æ›´å¥½ï¼‰
        } finally {
            nonFairLock.unlock();
        }
    }
}
```

**å¯¹æ¯”ï¼š**

| ç‰¹æ€§ | å…¬å¹³é” | éå…¬å¹³é” |
|------|--------|----------|
| **é¡ºåºä¿è¯** | æŒ‰è¯·æ±‚é¡ºåºåˆ†é… | ä¸ä¿è¯é¡ºåº |
| **æ€§èƒ½** | è¾ƒä½ï¼ˆéœ€è¦ç»´æŠ¤é˜Ÿåˆ—ï¼‰ | è¾ƒé«˜ï¼ˆé»˜è®¤ï¼‰ |
| **é€‚ç”¨åœºæ™¯** | éœ€è¦å…¬å¹³æ€§çš„åœºæ™¯ | å¤§å¤šæ•°åœºæ™¯ï¼ˆé»˜è®¤ï¼‰ |

### 2.6 æ¡ä»¶å˜é‡ï¼ˆConditionï¼‰

```java
import java.util.concurrent.locks.Condition;

/**
 * Conditionæ¡ä»¶å˜é‡ç¤ºä¾‹
 * Condition Example
 */
public class ConditionDemo {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private boolean ready = false;
    
    public void waitForReady() throws InterruptedException {
        lock.lock();
        try {
            while (!ready) {
                condition.await(); // ç­‰å¾…æ¡ä»¶æ»¡è¶³
            }
            // æ¡ä»¶æ»¡è¶³ï¼Œç»§ç»­æ‰§è¡Œ
        } finally {
            lock.unlock();
        }
    }
    
    public void setReady() {
        lock.lock();
        try {
            ready = true;
            condition.signalAll(); // å”¤é†’æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹
        } finally {
            lock.unlock();
        }
    }
}
```

**Conditionçš„ä¼˜åŠ¿ï¼š**
- å¯ä»¥åˆ›å»ºå¤šä¸ªæ¡ä»¶å˜é‡
- æ›´çµæ´»çš„çº¿ç¨‹é—´é€šä¿¡
- ç±»ä¼¼`Object.wait()`å’Œ`notify()`ï¼Œä½†æ›´å¼ºå¤§

---

## 3. ReadWriteLock (ReadWriteLock)

### 3.1 æ ¸å¿ƒç‰¹ç‚¹

**ReadWriteLockï¼ˆè¯»å†™é”ï¼‰**å°†é”åˆ†ä¸ºè¯»é”å’Œå†™é”ï¼Œå®ç°è¯»å†™åˆ†ç¦»ã€‚

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **è¯»é”** | å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶æŒæœ‰è¯»é” |
| **å†™é”** | å†™é”æ˜¯æ’ä»–çš„ï¼Œä¸å…¶ä»–é”äº’æ–¥ |
| **è¯»å†™åˆ†ç¦»** | è¯»å¤šå†™å°‘åœºæ™¯æ€§èƒ½æ›´å¥½ |
| **é™çº§** | æ”¯æŒé”é™çº§ï¼ˆå†™é”é™çº§ä¸ºè¯»é”ï¼‰ |

### 3.2 åŸºæœ¬ä½¿ç”¨

```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * ReadWriteLockåŸºæœ¬ä½¿ç”¨
 * Basic Usage of ReadWriteLock
 */
public class ReadWriteLockDemo {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private Map<String, String> cache = new HashMap<>();
    
    // è¯»æ“ä½œï¼šä½¿ç”¨è¯»é”
    public String get(String key) {
        lock.readLock().lock();
        try {
            return cache.get(key);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    // å†™æ“ä½œï¼šä½¿ç”¨å†™é”
    public void put(String key, String value) {
        lock.writeLock().lock();
        try {
            cache.put(key, value);
        } finally {
            lock.writeLock().unlock();
        }
    }
}
```

### 3.3 é”çš„å…¼å®¹æ€§

```
è¯»é” vs è¯»é”ï¼šâœ… å…¼å®¹ï¼ˆå¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶æŒæœ‰è¯»é”ï¼‰
è¯»é” vs å†™é”ï¼šâŒ äº’æ–¥
å†™é” vs å†™é”ï¼šâŒ äº’æ–¥
```

### 3.4 é”é™çº§

```java
/**
 * é”é™çº§ç¤ºä¾‹
 * Lock Downgrade Example
 */
public class LockDowngradeDemo {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private volatile boolean update = false;
    
    public void processData() {
        lock.readLock().lock();
        if (!update) {
            lock.readLock().unlock();
            
            // å‡çº§ä¸ºå†™é”
            lock.writeLock().lock();
            try {
                if (!update) {
                    // æ›´æ–°æ•°æ®
                    updateData();
                    update = true;
                }
                // é™çº§ä¸ºè¯»é”
                lock.readLock().lock();
            } finally {
                lock.writeLock().unlock(); // é‡Šæ”¾å†™é”ï¼Œä½†æŒæœ‰è¯»é”
            }
        }
        
        try {
            // ä½¿ç”¨è¯»é”è¯»å–æ•°æ®
            readData();
        } finally {
            lock.readLock().unlock();
        }
    }
}
```

**æ³¨æ„ï¼š** ReadWriteLockä¸æ”¯æŒé”å‡çº§ï¼ˆè¯»é”å‡çº§ä¸ºå†™é”ï¼‰ï¼Œåªæ”¯æŒé™çº§ã€‚

### 3.5 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„ReadWriteLockåº”ç”¨
 * ReadWriteLock in Computing Platform
 */
public class PlatformReadWriteLock {
    private final ReadWriteLock configLock = new ReentrantReadWriteLock();
    private Map<String, Object> configMap = new ConcurrentHashMap<>();
    
    // è¯»é…ç½®ï¼šé¢‘ç¹æ“ä½œï¼Œä½¿ç”¨è¯»é”
    public Object getConfig(String key) {
        configLock.readLock().lock();
        try {
            return configMap.get(key);
        } finally {
            configLock.readLock().unlock();
        }
    }
    
    // æ›´æ–°é…ç½®ï¼šä½é¢‘æ“ä½œï¼Œä½¿ç”¨å†™é”
    public void updateConfig(String key, Object value) {
        configLock.writeLock().lock();
        try {
            configMap.put(key, value);
            // é€šçŸ¥é…ç½®å˜æ›´
            notifyConfigChange(key, value);
        } finally {
            configLock.writeLock().unlock();
        }
    }
    
    // æ‰¹é‡è¯»å–é…ç½®ï¼šè¯»é”å…è®¸å¹¶å‘
    public Map<String, Object> getAllConfigs() {
        configLock.readLock().lock();
        try {
            return new HashMap<>(configMap); // è¿”å›å‰¯æœ¬
        } finally {
            configLock.readLock().unlock();
        }
    }
}
```

---

## 4. StampedLock (StampedLock)

### 4.1 æ ¸å¿ƒç‰¹ç‚¹

**StampedLockï¼ˆæˆ³è®°é”ï¼‰**æ˜¯JDK 1.8å¼•å…¥çš„æ–°é”ï¼Œæä¾›äº†ä¸‰ç§æ¨¡å¼ï¼š

| æ¨¡å¼ | è¯´æ˜ | ç‰¹ç‚¹ |
|------|------|------|
| **å†™é”** | æ’ä»–é” | ä¸å…¶ä»–é”äº’æ–¥ |
| **è¯»é”** | å…±äº«é” | å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶æŒæœ‰ |
| **ä¹è§‚è¯»** | æ— é”è¯»å– | æ€§èƒ½æœ€å¥½ï¼Œä½†éœ€è¦éªŒè¯ |

### 4.2 åŸºæœ¬ä½¿ç”¨

```java
import java.util.concurrent.locks.StampedLock;

/**
 * StampedLockåŸºæœ¬ä½¿ç”¨
 * Basic Usage of StampedLock
 */
public class StampedLockDemo {
    private final StampedLock lock = new StampedLock();
    private double x, y;
    
    // å†™é”
    public void move(double deltaX, double deltaY) {
        long stamp = lock.writeLock(); // è·å–å†™é”ï¼Œè¿”å›æˆ³è®°
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            lock.unlockWrite(stamp); // ä½¿ç”¨æˆ³è®°é‡Šæ”¾é”
        }
    }
    
    // è¯»é”
    public double distanceFromOrigin() {
        long stamp = lock.readLock(); // è·å–è¯»é”
        try {
            return Math.sqrt(x * x + y * y);
        } finally {
            lock.unlockRead(stamp);
        }
    }
    
    // ä¹è§‚è¯»ï¼ˆæ€§èƒ½æœ€å¥½ï¼‰
    public double optimisticDistanceFromOrigin() {
        long stamp = lock.tryOptimisticRead(); // å°è¯•ä¹è§‚è¯»
        double currentX = x, currentY = y;
        
        if (!lock.validate(stamp)) { // éªŒè¯æˆ³è®°æ˜¯å¦æœ‰æ•ˆ
            // æˆ³è®°æ— æ•ˆï¼Œå‡çº§ä¸ºè¯»é”
            stamp = lock.readLock();
            try {
                currentX = x;
                currentY = y;
            } finally {
                lock.unlockRead(stamp);
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
}
```

### 4.3 ä¹è§‚è¯»çš„ä¼˜åŠ¿

**ä¹è§‚è¯»ï¼ˆOptimistic Readï¼‰**æ˜¯æ— é”è¯»å–ï¼Œæ€§èƒ½æœ€å¥½ï¼š

```java
/**
 * ä¹è§‚è¯»ç¤ºä¾‹
 * Optimistic Read Example
 */
public class OptimisticReadDemo {
    private final StampedLock lock = new StampedLock();
    private int value = 0;
    
    public int optimisticRead() {
        long stamp = lock.tryOptimisticRead(); // æ— é”è¯»å–
        int currentValue = value;
        
        // éªŒè¯æœŸé—´æ˜¯å¦æœ‰å†™æ“ä½œ
        if (lock.validate(stamp)) {
            return currentValue; // æˆ³è®°æœ‰æ•ˆï¼Œç›´æ¥è¿”å›
        } else {
            // æˆ³è®°æ— æ•ˆï¼Œå‡çº§ä¸ºè¯»é”
            stamp = lock.readLock();
            try {
                return value;
            } finally {
                lock.unlockRead(stamp);
            }
        }
    }
    
    public void write(int newValue) {
        long stamp = lock.writeLock();
        try {
            value = newValue;
        } finally {
            lock.unlockWrite(stamp);
        }
    }
}
```

**é€‚ç”¨åœºæ™¯ï¼š** è¯»å¤šå†™å°‘ï¼Œä¸”è¯»æ“ä½œä¸éœ€è¦å¼ºä¸€è‡´æ€§ã€‚

### 4.4 StampedLock vs ReadWriteLock

| ç‰¹æ€§ | ReadWriteLock | StampedLock |
|------|--------------|-------------|
| **è¯»é”** | æ”¯æŒ | æ”¯æŒ |
| **å†™é”** | æ”¯æŒ | æ”¯æŒ |
| **ä¹è§‚è¯»** | ä¸æ”¯æŒ | æ”¯æŒï¼ˆæ€§èƒ½æœ€å¥½ï¼‰ |
| **é”é™çº§** | æ”¯æŒ | ä¸æ”¯æŒ |
| **å¯é‡å…¥** | æ”¯æŒ | ä¸æ”¯æŒ |
| **æ€§èƒ½** | è¾ƒå¥½ | æ›´å¥½ï¼ˆä¹è§‚è¯»ï¼‰ |

---

## 5. é”çš„æ€§èƒ½å¯¹æ¯” (Lock Performance Comparison)

### 5.1 æ€§èƒ½æµ‹è¯•åœºæ™¯

| åœºæ™¯ | synchronized | ReentrantLock | ReadWriteLock | StampedLock |
|------|-------------|---------------|---------------|-------------|
| **é«˜ç«äº‰å†™** | ä¸­ç­‰ | è¾ƒå¥½ | è¾ƒå·® | æœ€å¥½ |
| **é«˜ç«äº‰è¯»** | ä¸­ç­‰ | ä¸­ç­‰ | æœ€å¥½ | æœ€å¥½ï¼ˆä¹è§‚è¯»ï¼‰ |
| **è¯»å¤šå†™å°‘** | ä¸­ç­‰ | ä¸­ç­‰ | æœ€å¥½ | æœ€å¥½ï¼ˆä¹è§‚è¯»ï¼‰ |
| **å†™å¤šè¯»å°‘** | è¾ƒå¥½ | è¾ƒå¥½ | è¾ƒå·® | æœ€å¥½ |

### 5.2 é€‰æ‹©å»ºè®®

**ä½¿ç”¨synchronizedï¼š**
- ç®€å•çš„åŒæ­¥åœºæ™¯
- ä¸éœ€è¦é«˜çº§åŠŸèƒ½ï¼ˆä¸­æ–­ã€è¶…æ—¶ç­‰ï¼‰

**ä½¿ç”¨ReentrantLockï¼š**
- éœ€è¦ä¸­æ–­æˆ–è¶…æ—¶åŠŸèƒ½
- éœ€è¦å…¬å¹³é”
- éœ€è¦å¤šä¸ªæ¡ä»¶å˜é‡

**ä½¿ç”¨ReadWriteLockï¼š**
- è¯»å¤šå†™å°‘åœºæ™¯
- éœ€è¦é”é™çº§

**ä½¿ç”¨StampedLockï¼š**
- è¯»å¤šå†™å°‘åœºæ™¯
- å¯ä»¥å®¹å¿ä¹è§‚è¯»çš„å¼±ä¸€è‡´æ€§
- è¿½æ±‚æœ€é«˜æ€§èƒ½

---

## 6. æœ€ä½³å®è·µ (Best Practices)

### 6.1 å§‹ç»ˆåœ¨finallyä¸­é‡Šæ”¾é”

```java
// âœ… æ­£ç¡®ï¼šåœ¨finallyä¸­é‡Šæ”¾é”
lock.lock();
try {
    // æ‰§è¡Œä»»åŠ¡
} finally {
    lock.unlock();
}

// âŒ é”™è¯¯ï¼šå¯èƒ½å¿˜è®°é‡Šæ”¾é”
lock.lock();
// æ‰§è¡Œä»»åŠ¡
lock.unlock(); // å¦‚æœä¸­é—´æŠ›å‡ºå¼‚å¸¸ï¼Œé”ä¸ä¼šè¢«é‡Šæ”¾
```

### 6.2 é¿å…åµŒå¥—é”

```java
// âŒ ä¸æ¨èï¼šåµŒå¥—é”å¯èƒ½å¯¼è‡´æ­»é”
lock1.lock();
try {
    lock2.lock(); // å¦‚æœå…¶ä»–çº¿ç¨‹ä»¥ç›¸åé¡ºåºè·å–é”ï¼Œå¯èƒ½æ­»é”
    try {
        // ...
    } finally {
        lock2.unlock();
    }
} finally {
    lock1.unlock();
}

// âœ… æ¨èï¼šç»Ÿä¸€é”é¡ºåº
// æˆ–è€…ä½¿ç”¨è¶…æ—¶é”
if (lock1.tryLock(5, TimeUnit.SECONDS)) {
    try {
        if (lock2.tryLock(5, TimeUnit.SECONDS)) {
            try {
                // ...
            } finally {
                lock2.unlock();
            }
        }
    } finally {
        lock1.unlock();
    }
}
```

### 6.3 é€‰æ‹©åˆé€‚çš„é”ç±»å‹

```java
// è¯»å¤šå†™å°‘ï¼šä½¿ç”¨ReadWriteLockæˆ–StampedLock
ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

// éœ€è¦è¶…æ—¶ï¼šä½¿ç”¨ReentrantLock
ReentrantLock lock = new ReentrantLock();
if (lock.tryLock(5, TimeUnit.SECONDS)) {
    // ...
}

// ç®€å•åœºæ™¯ï¼šä½¿ç”¨synchronized
synchronized (this) {
    // ...
}
```

---

## 7. é¢è¯•é«˜é¢‘é—®é¢˜ (Interview Questions)

### Q1: ReentrantLockå’Œsynchronizedçš„åŒºåˆ«ï¼Ÿ

**ç­”æ¡ˆï¼š**

| ç‰¹æ€§ | synchronized | ReentrantLock |
|------|-------------|---------------|
| **å¯ä¸­æ–­** | å¦ | æ˜¯ |
| **å¯è¶…æ—¶** | å¦ | æ˜¯ |
| **å…¬å¹³é”** | å¦ï¼ˆéå…¬å¹³ï¼‰ | æ˜¯ï¼ˆå¯é€‰ï¼‰ |
| **æ¡ä»¶å˜é‡** | å•ä¸€ï¼ˆwait/notifyï¼‰ | å¤šä¸ªï¼ˆConditionï¼‰ |
| **æ€§èƒ½** | JVMä¼˜åŒ–åè¾ƒå¥½ | è¾ƒå¥½ |
| **ä½¿ç”¨** | ç®€å• | éœ€è¦æ‰‹åŠ¨é‡Šæ”¾ |

### Q2: ReadWriteLockçš„å®ç°åŸç†ï¼Ÿ

**ç­”æ¡ˆï¼š** å†…éƒ¨ç»´æŠ¤è¯»é”è®¡æ•°å™¨å’Œå†™é”çŠ¶æ€ï¼Œè¯»é”å¯ä»¥å…±äº«ï¼Œå†™é”æ’ä»–ã€‚

### Q3: StampedLockçš„ä¹è§‚è¯»æ˜¯ä»€ä¹ˆï¼Ÿ

**ç­”æ¡ˆï¼š** æ— é”è¯»å–ï¼Œé€šè¿‡æˆ³è®°éªŒè¯æ˜¯å¦æœ‰å†™æ“ä½œï¼Œæ€§èƒ½æœ€å¥½ä½†éœ€è¦éªŒè¯ã€‚

### Q4: å¦‚ä½•é¿å…æ­»é”ï¼Ÿ

**ç­”æ¡ˆï¼š**
1. é¿å…åµŒå¥—é”
2. ç»Ÿä¸€é”é¡ºåº
3. ä½¿ç”¨è¶…æ—¶é”
4. ä½¿ç”¨é”è¶…æ—¶æœºåˆ¶

### Q5: é”é™çº§å’Œé”å‡çº§çš„åŒºåˆ«ï¼Ÿ

**ç­”æ¡ˆï¼š**
- **é”é™çº§**ï¼šå†™é”é™çº§ä¸ºè¯»é”ï¼ˆReadWriteLockæ”¯æŒï¼‰
- **é”å‡çº§**ï¼šè¯»é”å‡çº§ä¸ºå†™é”ï¼ˆReadWriteLockä¸æ”¯æŒï¼Œå¯èƒ½å¯¼è‡´æ­»é”ï¼‰

---

## ğŸ“– æ‰©å±•é˜…è¯»

- [ReentrantLock API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html)
- [ReadWriteLock API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html)
- [StampedLock API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html)

---

**è¿”å›ï¼š** [07-Javaå¹¶å‘ç¼–ç¨‹](./07-Javaå¹¶å‘ç¼–ç¨‹.md)  
**ä¸Šä¸€ç« ï¼š** [07-02 - çº¿ç¨‹åŒæ­¥ä¸å†…å­˜æ¨¡å‹](./07-02-çº¿ç¨‹åŒæ­¥ä¸å†…å­˜æ¨¡å‹.md)  
**ä¸‹ä¸€ç« ï¼š** [07-04 - å¹¶å‘å·¥å…·ç±» â†’](./07-04-å¹¶å‘å·¥å…·ç±».md)

