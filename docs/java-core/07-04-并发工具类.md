# å¹¶å‘å·¥å…·ç±» (Concurrent Utilities)

> æ·±å…¥ç†è§£CountDownLatchã€CyclicBarrierã€Semaphoreã€Exchangerã€Phaserç­‰JUCå·¥å…·ç±»çš„ä½¿ç”¨åœºæ™¯å’Œå®ç°åŸç†

## ç›®å½•
- [1. CountDownLatch](#1-countdownlatch)
- [2. CyclicBarrier](#2-cyclicbarrier)
- [3. Semaphore](#3-semaphore)
- [4. Exchanger](#4-exchanger)
- [5. Phaser](#5-phaser)
- [6. å·¥å…·ç±»å¯¹æ¯”](#6-å·¥å…·ç±»å¯¹æ¯”)
- [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
- [8. é¢è¯•é«˜é¢‘é—®é¢˜](#8-é¢è¯•é«˜é¢‘é—®é¢˜)

---

## 1. CountDownLatch (CountDownLatch)

### 1.1 æ ¸å¿ƒç‰¹ç‚¹

**CountDownLatchï¼ˆå€’è®¡æ—¶é—¨é—©ï¼‰**ï¼šä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ç­‰å¾…å…¶ä»–çº¿ç¨‹å®Œæˆæ“ä½œã€‚

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **ä¸€æ¬¡æ€§** | è®¡æ•°å™¨åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œä¸èƒ½é‡ç½® |
| **ç­‰å¾…æœºåˆ¶** | ä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ç­‰å¾…è®¡æ•°å™¨å½’é›¶ |
| **è®¡æ•°é€’å‡** | å…¶ä»–çº¿ç¨‹è°ƒç”¨countDown()é€’å‡è®¡æ•° |
| **é€‚ç”¨åœºæ™¯** | ç­‰å¾…å¤šä¸ªä»»åŠ¡å®Œæˆ |

### 1.2 åŸºæœ¬ä½¿ç”¨

```java
import java.util.concurrent.CountDownLatch;

/**
 * CountDownLatchåŸºæœ¬ä½¿ç”¨
 * Basic Usage of CountDownLatch
 */
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        int threadCount = 5;
        CountDownLatch latch = new CountDownLatch(threadCount);
        
        // åˆ›å»ºå¤šä¸ªå·¥ä½œçº¿ç¨‹
        for (int i = 0; i < threadCount; i++) {
            final int taskId = i;
            new Thread(() -> {
                try {
                    // æ‰§è¡Œä»»åŠ¡
                    System.out.println("ä»»åŠ¡" + taskId + "æ‰§è¡Œä¸­");
                    Thread.sleep(1000);
                    System.out.println("ä»»åŠ¡" + taskId + "å®Œæˆ");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown(); // è®¡æ•°å‡1
                }
            }).start();
        }
        
        // ä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        latch.await(); // é˜»å¡ç›´åˆ°è®¡æ•°å™¨å½’é›¶
        System.out.println("æ‰€æœ‰ä»»åŠ¡å®Œæˆ");
    }
}
```

### 1.3 æ ¸å¿ƒæ–¹æ³•

```java
// åˆ›å»ºï¼šæŒ‡å®šåˆå§‹è®¡æ•°
CountDownLatch latch = new CountDownLatch(5);

// ç­‰å¾…ï¼šé˜»å¡ç›´åˆ°è®¡æ•°å½’é›¶
latch.await();

// è¶…æ—¶ç­‰å¾…ï¼šè®¾ç½®è¶…æ—¶æ—¶é—´
boolean completed = latch.await(5, TimeUnit.SECONDS);

// è®¡æ•°å‡1ï¼šä¸é˜»å¡
latch.countDown();

// è·å–å½“å‰è®¡æ•°
long count = latch.getCount();
```

### 1.4 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„CountDownLatchåº”ç”¨
 * CountDownLatch in Computing Platform
 */
public class PlatformCountDownLatch {
    
    // åœºæ™¯ï¼šç­‰å¾…æ‰€æœ‰èŠ‚ç‚¹ä¿¡æ¯é‡‡é›†å®Œæˆ
    public void collectAllNodeInfo(List<Node> nodes) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(nodes.size());
        
        // å¹¶å‘é‡‡é›†æ‰€æœ‰èŠ‚ç‚¹ä¿¡æ¯
        for (Node node : nodes) {
            executorService.submit(() -> {
                try {
                    collectNodeInfo(node); // é‡‡é›†èŠ‚ç‚¹ä¿¡æ¯
                } finally {
                    latch.countDown(); // å®Œæˆä¸€ä¸ªèŠ‚ç‚¹
                }
            });
        }
        
        // ç­‰å¾…æ‰€æœ‰èŠ‚ç‚¹é‡‡é›†å®Œæˆ
        latch.await();
        System.out.println("æ‰€æœ‰èŠ‚ç‚¹ä¿¡æ¯é‡‡é›†å®Œæˆ");
        
        // ç»§ç»­åç»­å¤„ç†
        processCollectedData();
    }
    
    // åœºæ™¯ï¼šç­‰å¾…å¤šä¸ªå®šæ—¶ä»»åŠ¡å®Œæˆåˆå§‹åŒ–
    public void initializeTasks() throws InterruptedException {
        CountDownLatch initLatch = new CountDownLatch(3);
        
        // åˆå§‹åŒ–ä»»åŠ¡è°ƒåº¦å™¨
        executorService.submit(() -> {
            initTaskScheduler();
            initLatch.countDown();
        });
        
        // åˆå§‹åŒ–èŠ‚ç‚¹ç›‘æ§
        executorService.submit(() -> {
            initNodeMonitor();
            initLatch.countDown();
        });
        
        // åˆå§‹åŒ–ç»“ç®—ç³»ç»Ÿ
        executorService.submit(() -> {
            initBillingSystem();
            initLatch.countDown();
        });
        
        // ç­‰å¾…æ‰€æœ‰åˆå§‹åŒ–å®Œæˆ
        initLatch.await();
        System.out.println("ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
    }
}
```

---

## 2. CyclicBarrier (CyclicBarrier)

### 2.1 æ ¸å¿ƒç‰¹ç‚¹

**CyclicBarrierï¼ˆå¾ªç¯å±éšœï¼‰**ï¼šå¤šä¸ªçº¿ç¨‹ç›¸äº’ç­‰å¾…ï¼Œåˆ°è¾¾å±éšœç‚¹åä¸€èµ·ç»§ç»­æ‰§è¡Œã€‚

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **å¯é‡ç”¨** | è®¡æ•°å™¨å¯ä»¥é‡ç½®ï¼Œå¯ä»¥å¤šæ¬¡ä½¿ç”¨ |
| **ç›¸äº’ç­‰å¾…** | å¤šä¸ªçº¿ç¨‹ç›¸äº’ç­‰å¾…åˆ°è¾¾å±éšœç‚¹ |
| **å±éšœåŠ¨ä½œ** | åˆ°è¾¾å±éšœç‚¹åå¯ä»¥æ‰§è¡ŒæŒ‡å®šåŠ¨ä½œ |
| **é€‚ç”¨åœºæ™¯** | åˆ†é˜¶æ®µä»»åŠ¡ï¼Œéœ€è¦åŒæ­¥ç‚¹ |

### 2.2 åŸºæœ¬ä½¿ç”¨

```java
import java.util.concurrent.CyclicBarrier;

/**
 * CyclicBarrieråŸºæœ¬ä½¿ç”¨
 * Basic Usage of CyclicBarrier
 */
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        int threadCount = 3;
        CyclicBarrier barrier = new CyclicBarrier(threadCount, () -> {
            // å±éšœåŠ¨ä½œï¼šæ‰€æœ‰çº¿ç¨‹åˆ°è¾¾åæ‰§è¡Œ
            System.out.println("æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾å±éšœç‚¹");
        });
        
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    System.out.println("çº¿ç¨‹" + threadId + "æ‰§è¡Œé˜¶æ®µ1");
                    Thread.sleep(1000);
                    barrier.await(); // ç­‰å¾…å…¶ä»–çº¿ç¨‹
                    
                    System.out.println("çº¿ç¨‹" + threadId + "æ‰§è¡Œé˜¶æ®µ2");
                    Thread.sleep(1000);
                    barrier.await(); // å†æ¬¡ç­‰å¾…
                    
                    System.out.println("çº¿ç¨‹" + threadId + "å®Œæˆ");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

### 2.3 CountDownLatch vs CyclicBarrier

| ç‰¹æ€§ | CountDownLatch | CyclicBarrier |
|------|---------------|---------------|
| **è®¡æ•°æ–¹å‘** | é€’å‡åˆ°0 | é€’å¢åˆ°æŒ‡å®šå€¼ |
| **å¯é‡ç”¨** | å¦ï¼ˆä¸€æ¬¡æ€§ï¼‰ | æ˜¯ï¼ˆå¯å¾ªç¯ä½¿ç”¨ï¼‰ |
| **ç­‰å¾…å…³ç³»** | ä¸€ä¸ª/å¤šä¸ªçº¿ç¨‹ç­‰å¾…å…¶ä»–çº¿ç¨‹ | å¤šä¸ªçº¿ç¨‹ç›¸äº’ç­‰å¾… |
| **é€‚ç”¨åœºæ™¯** | ç­‰å¾…ä»»åŠ¡å®Œæˆ | åˆ†é˜¶æ®µåŒæ­¥ |

### 2.4 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„CyclicBarrieråº”ç”¨
 * CyclicBarrier in Computing Platform
 */
public class PlatformCyclicBarrier {
    
    // åœºæ™¯ï¼šåˆ†é˜¶æ®µå¤„ç†ä»»åŠ¡
    public void processTasksInPhases(List<Task> tasks) {
        int phaseCount = 3;
        CyclicBarrier barrier = new CyclicBarrier(tasks.size(), () -> {
            System.out.println("å½“å‰é˜¶æ®µå®Œæˆï¼Œè¿›å…¥ä¸‹ä¸€é˜¶æ®µ");
        });
        
        for (Task task : tasks) {
            executorService.submit(() -> {
                try {
                    // é˜¶æ®µ1ï¼šæ•°æ®å‡†å¤‡
                    prepareData(task);
                    barrier.await();
                    
                    // é˜¶æ®µ2ï¼šæ•°æ®å¤„ç†
                    processData(task);
                    barrier.await();
                    
                    // é˜¶æ®µ3ï¼šç»“æœè¾“å‡º
                    outputResult(task);
                    barrier.await();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
```

---

## 3. Semaphore (Semaphore)

### 3.1 æ ¸å¿ƒç‰¹ç‚¹

**Semaphoreï¼ˆä¿¡å·é‡ï¼‰**ï¼šæ§åˆ¶åŒæ—¶è®¿é—®èµ„æºçš„çº¿ç¨‹æ•°é‡ã€‚

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **è®¸å¯æœºåˆ¶** | é€šè¿‡è®¸å¯ï¼ˆpermitsï¼‰æ§åˆ¶è®¿é—® |
| **å¯é‡ç”¨** | è®¸å¯å¯ä»¥é‡Šæ”¾ï¼Œå¯ä»¥é‡å¤ä½¿ç”¨ |
| **å…¬å¹³æ€§** | æ”¯æŒå…¬å¹³å’Œéå…¬å¹³æ¨¡å¼ |
| **é€‚ç”¨åœºæ™¯** | é™æµã€èµ„æºæ± ç®¡ç† |

### 3.2 åŸºæœ¬ä½¿ç”¨

```java
import java.util.concurrent.Semaphore;

/**
 * SemaphoreåŸºæœ¬ä½¿ç”¨
 * Basic Usage of Semaphore
 */
public class SemaphoreDemo {
    public static void main(String[] args) {
        // åˆ›å»ºä¿¡å·é‡ï¼šæœ€å¤š3ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®
        Semaphore semaphore = new Semaphore(3);
        
        for (int i = 0; i < 10; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    semaphore.acquire(); // è·å–è®¸å¯
                    System.out.println("çº¿ç¨‹" + threadId + "è·å¾—è®¸å¯ï¼Œå¼€å§‹æ‰§è¡Œ");
                    Thread.sleep(2000);
                    System.out.println("çº¿ç¨‹" + threadId + "æ‰§è¡Œå®Œæˆ");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    semaphore.release(); // é‡Šæ”¾è®¸å¯
                }
            }).start();
        }
    }
}
```

### 3.3 æ ¸å¿ƒæ–¹æ³•

```java
// åˆ›å»ºï¼šæŒ‡å®šè®¸å¯æ•°é‡
Semaphore semaphore = new Semaphore(5);

// å…¬å¹³æ¨¡å¼
Semaphore fairSemaphore = new Semaphore(5, true);

// è·å–è®¸å¯ï¼ˆé˜»å¡ï¼‰
semaphore.acquire();

// è·å–å¤šä¸ªè®¸å¯
semaphore.acquire(3);

// å°è¯•è·å–è®¸å¯ï¼ˆéé˜»å¡ï¼‰
boolean acquired = semaphore.tryAcquire();

// è¶…æ—¶è·å–è®¸å¯
boolean acquired = semaphore.tryAcquire(5, TimeUnit.SECONDS);

// é‡Šæ”¾è®¸å¯
semaphore.release();

// é‡Šæ”¾å¤šä¸ªè®¸å¯
semaphore.release(3);

// è·å–å¯ç”¨è®¸å¯æ•°
int available = semaphore.availablePermits();
```

### 3.4 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„Semaphoreåº”ç”¨
 * Semaphore in Computing Platform
 */
public class PlatformSemaphore {
    
    // åœºæ™¯1ï¼šé™åˆ¶å¹¶å‘è¯·æ±‚Nomad APIçš„æ•°é‡
    private Semaphore nomadApiSemaphore = new Semaphore(10); // æœ€å¤š10ä¸ªå¹¶å‘è¯·æ±‚
    
    public void callNomadApi(String endpoint) throws InterruptedException {
        nomadApiSemaphore.acquire(); // è·å–è®¸å¯
        try {
            // è°ƒç”¨Nomad API
            nomadClient.get(endpoint);
        } finally {
            nomaphore.release(); // é‡Šæ”¾è®¸å¯
        }
    }
    
    // åœºæ™¯2ï¼šé™åˆ¶æ•°æ®åº“è¿æ¥æ•°
    private Semaphore dbConnectionSemaphore = new Semaphore(20); // æœ€å¤š20ä¸ªè¿æ¥
    
    public void executeQuery(String sql) throws InterruptedException {
        dbConnectionSemaphore.acquire();
        try {
            // æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢
            connection.execute(sql);
        } finally {
            dbConnectionSemaphore.release();
        }
    }
    
    // åœºæ™¯3ï¼šé™æµï¼šé™åˆ¶ä»»åŠ¡æäº¤é€Ÿç‡
    private Semaphore taskSubmissionSemaphore = new Semaphore(100); // æœ€å¤š100ä¸ªå¾…å¤„ç†ä»»åŠ¡
    
    public void submitTask(Task task) throws InterruptedException {
        if (taskSubmissionSemaphore.tryAcquire(5, TimeUnit.SECONDS)) {
            try {
                // æäº¤ä»»åŠ¡
                taskQueue.put(task);
            } finally {
                taskSubmissionSemaphore.release();
            }
        } else {
            throw new TooManyTasksException("ä»»åŠ¡æäº¤è¿‡å¤šï¼Œè¯·ç¨åé‡è¯•");
        }
    }
}
```

---

## 4. Exchanger (Exchanger)

### 4.1 æ ¸å¿ƒç‰¹ç‚¹

**Exchangerï¼ˆäº¤æ¢å™¨ï¼‰**ï¼šä¸¤ä¸ªçº¿ç¨‹åœ¨åŒæ­¥ç‚¹äº¤æ¢æ•°æ®ã€‚

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **æˆå¯¹äº¤æ¢** | åªèƒ½ä¸¤ä¸ªçº¿ç¨‹äº¤æ¢æ•°æ® |
| **åŒæ­¥ç‚¹** | ä¸¤ä¸ªçº¿ç¨‹éƒ½åˆ°è¾¾äº¤æ¢ç‚¹æ‰äº¤æ¢ |
| **é€‚ç”¨åœºæ™¯** | ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ã€æ•°æ®äº¤æ¢ |

### 4.2 åŸºæœ¬ä½¿ç”¨

```java
import java.util.concurrent.Exchanger;

/**
 * ExchangeråŸºæœ¬ä½¿ç”¨
 * Basic Usage of Exchanger
 */
public class ExchangerDemo {
    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();
        
        // ç”Ÿäº§è€…çº¿ç¨‹
        new Thread(() -> {
            try {
                String data = "ç”Ÿäº§çš„æ•°æ®";
                System.out.println("ç”Ÿäº§è€…å‘é€: " + data);
                String received = exchanger.exchange(data); // äº¤æ¢æ•°æ®
                System.out.println("ç”Ÿäº§è€…æ”¶åˆ°: " + received);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        // æ¶ˆè´¹è€…çº¿ç¨‹
        new Thread(() -> {
            try {
                Thread.sleep(1000); // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
                String data = "å¤„ç†åçš„æ•°æ®";
                System.out.println("æ¶ˆè´¹è€…å‘é€: " + data);
                String received = exchanger.exchange(data); // äº¤æ¢æ•°æ®
                System.out.println("æ¶ˆè´¹è€…æ”¶åˆ°: " + received);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

### 4.3 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„Exchangeråº”ç”¨
 * Exchanger in Computing Platform
 */
public class PlatformExchanger {
    
    // åœºæ™¯ï¼šæ•°æ®è½¬æ¢ç®¡é“
    public void dataPipeline() {
        Exchanger<Data> exchanger = new Exchanger<>();
        
        // æ•°æ®é‡‡é›†çº¿ç¨‹
        executorService.submit(() -> {
            try {
                while (true) {
                    Data rawData = collectData(); // é‡‡é›†åŸå§‹æ•°æ®
                    Data processedData = exchanger.exchange(rawData); // äº¤æ¢å¤„ç†åçš„æ•°æ®
                    storeData(processedData); // å­˜å‚¨æ•°æ®
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // æ•°æ®å¤„ç†çº¿ç¨‹
        executorService.submit(() -> {
            try {
                while (true) {
                    Data rawData = exchanger.exchange(null); // ç­‰å¾…åŸå§‹æ•°æ®
                    Data processedData = processData(rawData); // å¤„ç†æ•°æ®
                    exchanger.exchange(processedData); // è¿”å›å¤„ç†åçš„æ•°æ®
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }
}
```

---

## 5. Phaser (Phaser)

### 5.1 æ ¸å¿ƒç‰¹ç‚¹

**Phaserï¼ˆé˜¶æ®µå™¨ï¼‰**ï¼šJDK 1.7å¼•å…¥ï¼Œå¯ä»¥åŠ¨æ€è°ƒæ•´å‚ä¸çº¿ç¨‹æ•°ï¼Œæ”¯æŒå¤šé˜¶æ®µåŒæ­¥ã€‚

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **åŠ¨æ€è°ƒæ•´** | å¯ä»¥åŠ¨æ€æ³¨å†Œå’Œæ³¨é”€çº¿ç¨‹ |
| **å¤šé˜¶æ®µ** | æ”¯æŒå¤šä¸ªé˜¶æ®µçš„åŒæ­¥ |
| **çµæ´»** | æ¯”CyclicBarrierå’ŒCountDownLatchæ›´çµæ´» |
| **é€‚ç”¨åœºæ™¯** | å¤æ‚çš„åˆ†é˜¶æ®µä»»åŠ¡ |

### 5.2 åŸºæœ¬ä½¿ç”¨

```java
import java.util.concurrent.Phaser;

/**
 * PhaseråŸºæœ¬ä½¿ç”¨
 * Basic Usage of Phaser
 */
public class PhaserDemo {
    public static void main(String[] args) {
        Phaser phaser = new Phaser(3); // 3ä¸ªå‚ä¸çº¿ç¨‹
        
        for (int i = 0; i < 3; i++) {
            final int threadId = i;
            new Thread(() -> {
                System.out.println("çº¿ç¨‹" + threadId + "æ‰§è¡Œé˜¶æ®µ1");
                phaser.arriveAndAwaitAdvance(); // åˆ°è¾¾å¹¶ç­‰å¾…
                
                System.out.println("çº¿ç¨‹" + threadId + "æ‰§è¡Œé˜¶æ®µ2");
                phaser.arriveAndAwaitAdvance();
                
                System.out.println("çº¿ç¨‹" + threadId + "å®Œæˆ");
                phaser.arriveAndDeregister(); // åˆ°è¾¾å¹¶æ³¨é”€
            }).start();
        }
    }
}
```

### 5.3 æ ¸å¿ƒæ–¹æ³•

```java
// åˆ›å»ºï¼šæŒ‡å®šåˆå§‹å‚ä¸çº¿ç¨‹æ•°
Phaser phaser = new Phaser(5);

// æ³¨å†Œçº¿ç¨‹
phaser.register();

// æ³¨é”€çº¿ç¨‹
phaser.arriveAndDeregister();

// åˆ°è¾¾å¹¶ç­‰å¾…å…¶ä»–çº¿ç¨‹
phaser.arriveAndAwaitAdvance();

// åˆ°è¾¾ä½†ä¸ç­‰å¾…
int phase = phaser.arrive();

// è·å–å½“å‰é˜¶æ®µ
int currentPhase = phaser.getPhase();

// è·å–æ³¨å†Œçš„çº¿ç¨‹æ•°
int parties = phaser.getRegisteredParties();
```

### 5.4 åœ¨ç®—åŠ›å¹³å°ä¸­çš„åº”ç”¨

```java
/**
 * ç®—åŠ›å¹³å°ä¸­çš„Phaseråº”ç”¨
 * Phaser in Computing Platform
 */
public class PlatformPhaser {
    
    // åœºæ™¯ï¼šå¤šé˜¶æ®µä»»åŠ¡å¤„ç†
    public void multiPhaseTaskProcessing(List<Task> tasks) {
        Phaser phaser = new Phaser(1); // ä¸»çº¿ç¨‹ä¹Ÿå‚ä¸
        
        for (Task task : tasks) {
            phaser.register(); // æ³¨å†Œä»»åŠ¡çº¿ç¨‹
            executorService.submit(() -> {
                try {
                    // é˜¶æ®µ1ï¼šå‡†å¤‡
                    prepareTask(task);
                    phaser.arriveAndAwaitAdvance();
                    
                    // é˜¶æ®µ2ï¼šæ‰§è¡Œ
                    executeTask(task);
                    phaser.arriveAndAwaitAdvance();
                    
                    // é˜¶æ®µ3ï¼šæ¸…ç†
                    cleanupTask(task);
                    phaser.arriveAndDeregister();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
        
        // ä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰é˜¶æ®µå®Œæˆ
        phaser.arriveAndAwaitAdvance(); // é˜¶æ®µ1
        phaser.arriveAndAwaitAdvance(); // é˜¶æ®µ2
        phaser.arriveAndAwaitAdvance(); // é˜¶æ®µ3
    }
}
```

---

## 6. å·¥å…·ç±»å¯¹æ¯” (Utilities Comparison)

### 6.1 åŠŸèƒ½å¯¹æ¯”è¡¨

| å·¥å…·ç±» | ä¸»è¦åŠŸèƒ½ | çº¿ç¨‹æ•° | å¯é‡ç”¨ | é€‚ç”¨åœºæ™¯ |
|--------|---------|--------|--------|---------|
| **CountDownLatch** | ç­‰å¾…ä»»åŠ¡å®Œæˆ | å¤šä¸ª | å¦ | ç­‰å¾…å¤šä¸ªä»»åŠ¡å®Œæˆ |
| **CyclicBarrier** | åˆ†é˜¶æ®µåŒæ­¥ | å¤šä¸ª | æ˜¯ | åˆ†é˜¶æ®µä»»åŠ¡åŒæ­¥ |
| **Semaphore** | æ§åˆ¶å¹¶å‘æ•° | å¤šä¸ª | æ˜¯ | é™æµã€èµ„æºæ±  |
| **Exchanger** | æ•°æ®äº¤æ¢ | 2ä¸ª | æ˜¯ | ä¸¤ä¸ªçº¿ç¨‹äº¤æ¢æ•°æ® |
| **Phaser** | å¤šé˜¶æ®µåŒæ­¥ | å¤šä¸ª | æ˜¯ | å¤æ‚åˆ†é˜¶æ®µä»»åŠ¡ |

### 6.2 é€‰æ‹©å»ºè®®

**ä½¿ç”¨CountDownLatchï¼š**
- ç­‰å¾…å¤šä¸ªä»»åŠ¡å®Œæˆ
- ä¸€æ¬¡æ€§ä½¿ç”¨

**ä½¿ç”¨CyclicBarrierï¼š**
- åˆ†é˜¶æ®µä»»åŠ¡éœ€è¦åŒæ­¥ç‚¹
- éœ€è¦é‡å¤ä½¿ç”¨

**ä½¿ç”¨Semaphoreï¼š**
- éœ€è¦é™åˆ¶å¹¶å‘æ•°
- é™æµåœºæ™¯

**ä½¿ç”¨Exchangerï¼š**
- ä¸¤ä¸ªçº¿ç¨‹éœ€è¦äº¤æ¢æ•°æ®
- ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

**ä½¿ç”¨Phaserï¼š**
- å¤æ‚çš„åˆ†é˜¶æ®µä»»åŠ¡
- éœ€è¦åŠ¨æ€è°ƒæ•´çº¿ç¨‹æ•°

---

## 7. æœ€ä½³å®è·µ (Best Practices)

### 7.1 CountDownLatchï¼šç¡®ä¿åœ¨finallyä¸­countDown

```java
// âœ… æ­£ç¡®
try {
    // æ‰§è¡Œä»»åŠ¡
} finally {
    latch.countDown(); // ç¡®ä¿è®¡æ•°å‡1
}

// âŒ é”™è¯¯ï¼šå¦‚æœå¼‚å¸¸ï¼Œè®¡æ•°ä¸ä¼šå‡1
latch.countDown();
// æ‰§è¡Œä»»åŠ¡ï¼ˆå¯èƒ½æŠ›å¼‚å¸¸ï¼‰
```

### 7.2 Semaphoreï¼šåˆç†è®¾ç½®è®¸å¯æ•°

```java
// æ ¹æ®ç³»ç»Ÿèµ„æºè®¾ç½®è®¸å¯æ•°
// CPUå¯†é›†å‹ï¼šè®¸å¯æ•° = CPUæ ¸å¿ƒæ•°
Semaphore cpuSemaphore = new Semaphore(Runtime.getRuntime().availableProcessors());

// IOå¯†é›†å‹ï¼šè®¸å¯æ•°å¯ä»¥æ›´å¤§
Semaphore ioSemaphore = new Semaphore(50);
```

### 7.3 CyclicBarrierï¼šå¤„ç†å¼‚å¸¸

```java
CyclicBarrier barrier = new CyclicBarrier(3, () -> {
    // å±éšœåŠ¨ä½œ
});

try {
    barrier.await();
} catch (BrokenBarrierException e) {
    // å¤„ç†å±éšœè¢«ç ´åçš„æƒ…å†µ
    // å…¶ä»–çº¿ç¨‹å¯èƒ½å·²ç»å¤±è´¥
}
```

---

## 8. é¢è¯•é«˜é¢‘é—®é¢˜ (Interview Questions)

### Q1: CountDownLatchå’ŒCyclicBarrierçš„åŒºåˆ«ï¼Ÿ

**ç­”æ¡ˆï¼š**
- CountDownLatchï¼šä¸€ä¸ª/å¤šä¸ªçº¿ç¨‹ç­‰å¾…å…¶ä»–çº¿ç¨‹å®Œæˆï¼Œä¸€æ¬¡æ€§ä½¿ç”¨
- CyclicBarrierï¼šå¤šä¸ªçº¿ç¨‹ç›¸äº’ç­‰å¾…åˆ°è¾¾å±éšœç‚¹ï¼Œå¯é‡ç”¨

### Q2: Semaphoreçš„å®ç°åŸç†ï¼Ÿ

**ç­”æ¡ˆï¼š** åŸºäºAQSï¼ˆAbstractQueuedSynchronizerï¼‰å®ç°ï¼Œé€šè¿‡è®¸å¯ï¼ˆpermitsï¼‰æ§åˆ¶å¹¶å‘æ•°ã€‚

### Q3: å¦‚ä½•å®ç°é™æµï¼Ÿ

**ç­”æ¡ˆï¼š** ä½¿ç”¨Semaphoreï¼Œè®¾ç½®è®¸å¯æ•°é™åˆ¶å¹¶å‘è¯·æ±‚æ•°ã€‚

### Q4: Exchangerçš„ä½¿ç”¨åœºæ™¯ï¼Ÿ

**ç­”æ¡ˆï¼š** ä¸¤ä¸ªçº¿ç¨‹éœ€è¦äº¤æ¢æ•°æ®çš„åœºæ™¯ï¼Œå¦‚ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ã€‚

### Q5: Phaserç›¸æ¯”CyclicBarrierçš„ä¼˜åŠ¿ï¼Ÿ

**ç­”æ¡ˆï¼š** å¯ä»¥åŠ¨æ€è°ƒæ•´å‚ä¸çº¿ç¨‹æ•°ï¼Œæ”¯æŒæ›´å¤æ‚çš„åˆ†é˜¶æ®µä»»åŠ¡ã€‚

---

## ğŸ“– æ‰©å±•é˜…è¯»

- [CountDownLatch API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html)
- [CyclicBarrier API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html)
- [Semaphore API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html)

---

**è¿”å›ï¼š** [07-Javaå¹¶å‘ç¼–ç¨‹](./07-Javaå¹¶å‘ç¼–ç¨‹.md)  
**ä¸Šä¸€ç« ï¼š** [07-03 - é”æœºåˆ¶](./07-03-é”æœºåˆ¶.md)  
**ä¸‹ä¸€ç« ï¼š** [07-05 - çº¿ç¨‹æ±  â†’](./07-05-çº¿ç¨‹æ± .md)

